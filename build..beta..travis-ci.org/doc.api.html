<style>
.docApiDiv {
font-family: Helvetical Neue, Helvetica, Arial, sans-serif;
}
.docApiDiv a {
color: #55f;
font-weight: bold;
text-decoration: none;
}
.docApiDiv a:hover {
text-decoration: underline;
}
.docApiSectionDiv {
border-top: 1px solid;
margin-top: 20px;
}
.docApiCodeCommentSpan {
background-color: #bbf;
color: #000;
display: block;
}
.docApiCodeKeywordSpan {
color: #f00;
font-weight: bold;
}
.docApiCodePre {
background-color: #eef;
border: 1px solid;
border-radius: 5px;
color: #777;
padding: 5px;
white-space: pre-wrap;
}
.docApiSignatureSpan {
color: #777;
}
</style>
<div class="docApiDiv">
<h1>api documentation</h1>
<div class="docApiSectionDiv" id="toc"><h1>table of contents</h1><ul>

<li><a href="#module.mongodb">module mongodb</a><ul>

<li><a class="docApiElementLiA" href="#element.mongodb.Binary">
function <span class="docApiSignatureSpan">mongodb.</span>Binary
<span class="docApiSignatureSpan">(buffer, subType)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Chunk">
function <span class="docApiSignatureSpan">mongodb.</span>Chunk
<span class="docApiSignatureSpan">(file, mongoObject, writeConcern)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Code">
function <span class="docApiSignatureSpan">mongodb.</span>Code
<span class="docApiSignatureSpan">(code, scope)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection">
function <span class="docApiSignatureSpan">mongodb.</span>Collection
<span class="docApiSignatureSpan">(db, topology, dbName, name, pkFactory, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Cursor">
function <span class="docApiSignatureSpan">mongodb.</span>Cursor
<span class="docApiSignatureSpan">(bson, ns, cmd, options, topology, topologyOptions)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.DBRef">
function <span class="docApiSignatureSpan">mongodb.</span>DBRef
<span class="docApiSignatureSpan">(namespace, oid, db)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Db">
function <span class="docApiSignatureSpan">mongodb.</span>Db
<span class="docApiSignatureSpan">(databaseName, topology, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Double">
function <span class="docApiSignatureSpan">mongodb.</span>Double
<span class="docApiSignatureSpan">(value)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.GridStore">
function <span class="docApiSignatureSpan">mongodb.</span>GridStore
<span class="docApiSignatureSpan">(db, id, filename, mode, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Logger">
function <span class="docApiSignatureSpan">mongodb.</span>Logger
<span class="docApiSignatureSpan">(className, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Long">
function <span class="docApiSignatureSpan">mongodb.</span>Long
<span class="docApiSignatureSpan">(low, high)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.MaxKey">
function <span class="docApiSignatureSpan">mongodb.</span>MaxKey
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.MinKey">
function <span class="docApiSignatureSpan">mongodb.</span>MinKey
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.MongoClient">
function <span class="docApiSignatureSpan">mongodb.</span>MongoClient
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.MongoError">
function <span class="docApiSignatureSpan">mongodb.</span>MongoError
<span class="docApiSignatureSpan">(message)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Mongos">
function <span class="docApiSignatureSpan">mongodb.</span>Mongos
<span class="docApiSignatureSpan">(servers, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.ObjectID">
function <span class="docApiSignatureSpan">mongodb.</span>ObjectID
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.ObjectId">
function <span class="docApiSignatureSpan">mongodb.</span>ObjectId
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.ReadPreference">
function <span class="docApiSignatureSpan">mongodb.</span>ReadPreference
<span class="docApiSignatureSpan">(mode, tags)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.ReplSet">
function <span class="docApiSignatureSpan">mongodb.</span>ReplSet
<span class="docApiSignatureSpan">(servers, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Server">
function <span class="docApiSignatureSpan">mongodb.</span>Server
<span class="docApiSignatureSpan">(host, port, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Symbol">
function <span class="docApiSignatureSpan">mongodb.</span>Symbol
<span class="docApiSignatureSpan">(value)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Timestamp">
function <span class="docApiSignatureSpan">mongodb.</span>Timestamp
<span class="docApiSignatureSpan">(low, high)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.connect">
function <span class="docApiSignatureSpan">mongodb.</span>connect
<span class="docApiSignatureSpan">(url, options, callback)</span>
</a></li>

</ul></li>

<li><a href="#module.mongodb.Collection">module mongodb.Collection</a><ul>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.aggregate">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>aggregate
<span class="docApiSignatureSpan">(pipeline, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.bulkWrite">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>bulkWrite
<span class="docApiSignatureSpan">(operations, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.count">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>count
<span class="docApiSignatureSpan">(query, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.createIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>createIndex
<span class="docApiSignatureSpan">(fieldOrSpec, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.createIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>createIndexes
<span class="docApiSignatureSpan">(indexSpecs, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.deleteMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>deleteMany
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.deleteOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>deleteOne
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.distinct">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>distinct
<span class="docApiSignatureSpan">(key, query, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.drop">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>drop
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.dropAllIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropAllIndexes
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.dropIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropIndex
<span class="docApiSignatureSpan">(indexName, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.dropIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropIndexes
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.ensureIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>ensureIndex
<span class="docApiSignatureSpan">(fieldOrSpec, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.find">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>find
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findAndModify">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findAndModify
<span class="docApiSignatureSpan">(query, sort, doc, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findAndRemove">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findAndRemove
<span class="docApiSignatureSpan">(query, sort, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOne
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findOneAndDelete">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndDelete
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findOneAndReplace">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndReplace
<span class="docApiSignatureSpan">(filter, replacement, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.findOneAndUpdate">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndUpdate
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.geoHaystackSearch">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>geoHaystackSearch
<span class="docApiSignatureSpan">(x, y, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.geoNear">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>geoNear
<span class="docApiSignatureSpan">(x, y, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.group">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>group
<span class="docApiSignatureSpan">(keys, condition, initial, reduce, finalize, command, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.indexExists">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexExists
<span class="docApiSignatureSpan">(indexes, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.indexInformation">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexInformation
<span class="docApiSignatureSpan">(options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.indexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexes
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.initializeOrderedBulkOp">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>initializeOrderedBulkOp
<span class="docApiSignatureSpan">(options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.initializeUnorderedBulkOp">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>initializeUnorderedBulkOp
<span class="docApiSignatureSpan">(options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.insert">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insert
<span class="docApiSignatureSpan">(docs, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.insertMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insertMany
<span class="docApiSignatureSpan">(docs, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.insertOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insertOne
<span class="docApiSignatureSpan">(doc, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.isCapped">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>isCapped
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.listIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>listIndexes
<span class="docApiSignatureSpan">(options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.mapReduce">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>mapReduce
<span class="docApiSignatureSpan">(map, reduce, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.options">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>options
<span class="docApiSignatureSpan">(callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.parallelCollectionScan">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>parallelCollectionScan
<span class="docApiSignatureSpan">(options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.reIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>reIndex
<span class="docApiSignatureSpan">(options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.remove">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>remove
<span class="docApiSignatureSpan">(selector, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.removeMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>removeMany
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.removeOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>removeOne
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.rename">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>rename
<span class="docApiSignatureSpan">(newName, opt, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.replaceOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>replaceOne
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.save">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>save
<span class="docApiSignatureSpan">(doc, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.stats">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>stats
<span class="docApiSignatureSpan">(options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.update">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>update
<span class="docApiSignatureSpan">(selector, document, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.updateMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>updateMany
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.Collection.updateOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>updateOne
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></li>

</ul></li>

<li><a href="#module.mongodb.MongoClient">module mongodb.MongoClient</a><ul>

<li><a class="docApiElementLiA" href="#element.mongodb.MongoClient.connect">
function <span class="docApiSignatureSpan">mongodb.MongoClient.</span>connect
<span class="docApiSignatureSpan">(url, options, callback)</span>
</a></li>

</ul></li>

<li><a href="#module.mongodb.bson">module mongodb.bson</a><ul>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.BSON">
function <span class="docApiSignatureSpan">mongodb.bson.</span>BSON
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Binary">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Binary
<span class="docApiSignatureSpan">(buffer, subType)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Code">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Code
<span class="docApiSignatureSpan">(code, scope)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.DBRef">
function <span class="docApiSignatureSpan">mongodb.bson.</span>DBRef
<span class="docApiSignatureSpan">(namespace, oid, db)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Double">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Double
<span class="docApiSignatureSpan">(value)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Long">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Long
<span class="docApiSignatureSpan">(low, high)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.MaxKey">
function <span class="docApiSignatureSpan">mongodb.bson.</span>MaxKey
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.MinKey">
function <span class="docApiSignatureSpan">mongodb.bson.</span>MinKey
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.ObjectID">
function <span class="docApiSignatureSpan">mongodb.bson.</span>ObjectID
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.ObjectId">
function <span class="docApiSignatureSpan">mongodb.bson.</span>ObjectId
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Symbol">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Symbol
<span class="docApiSignatureSpan">(value)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.Timestamp">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Timestamp
<span class="docApiSignatureSpan">(low, high)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.native">
function <span class="docApiSignatureSpan">mongodb.bson.</span>native
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.bson.pure">
function <span class="docApiSignatureSpan">mongodb.bson.</span>pure
<span class="docApiSignatureSpan">()</span>
</a></li>

</ul></li>

<li><a href="#module.mongodb.core">module mongodb.core</a><ul>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Cursor">
function <span class="docApiSignatureSpan">mongodb.core.</span>Cursor
<span class="docApiSignatureSpan">(bson, ns, cmd, options, topology, topologyOptions)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.GSSAPI">
function <span class="docApiSignatureSpan">mongodb.core.</span>GSSAPI
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Logger">
function <span class="docApiSignatureSpan">mongodb.core.</span>Logger
<span class="docApiSignatureSpan">(className, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.MongoCR">
function <span class="docApiSignatureSpan">mongodb.core.</span>MongoCR
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.MongoError">
function <span class="docApiSignatureSpan">mongodb.core.</span>MongoError
<span class="docApiSignatureSpan">(message)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Mongos">
function <span class="docApiSignatureSpan">mongodb.core.</span>Mongos
<span class="docApiSignatureSpan">(seedlist, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Plain">
function <span class="docApiSignatureSpan">mongodb.core.</span>Plain
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Query">
function <span class="docApiSignatureSpan">mongodb.core.</span>Query
<span class="docApiSignatureSpan">(bson, ns, query, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.ReadPreference">
function <span class="docApiSignatureSpan">mongodb.core.</span>ReadPreference
<span class="docApiSignatureSpan">(preference, tags, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.ReplSet">
function <span class="docApiSignatureSpan">mongodb.core.</span>ReplSet
<span class="docApiSignatureSpan">(seedlist, options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.ScramSHA1">
function <span class="docApiSignatureSpan">mongodb.core.</span>ScramSHA1
<span class="docApiSignatureSpan">()</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.Server">
function <span class="docApiSignatureSpan">mongodb.core.</span>Server
<span class="docApiSignatureSpan">(options)</span>
</a></li>

<li><a class="docApiElementLiA" href="#element.mongodb.core.X509">
function <span class="docApiSignatureSpan">mongodb.core.</span>X509
<span class="docApiSignatureSpan">()</span>
</a></li>

</ul></li>

</ul></div>

<div class="docApiSectionDiv">
<h1><a href="#module.mongodb" id="module.mongodb">module mongodb</a></h1>

<h2><a href="#element.mongodb.Binary" id="element.mongodb.Binary">
function <span class="docApiSignatureSpan">mongodb.</span>Binary
<span class="docApiSignatureSpan">(buffer, subType)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);
  
  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {    
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null && !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;      
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);      
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

  // The actual test we wish to run
  test: function(configuration, test) {
var Binary = configuration.require.Binary;
var docs = []

for(var i = 0; i &lt; 10000; i++) {
  docs.push({'a':i, bin: new <span class="docApiCodeKeywordSpan">Binary</span>(new Buffer(256))})
}

var db = configuration.newDbInstance({w:0}, {poolSize:1});
var j = 0;

var allDocs = [];
while(docs.length &gt; 0) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Chunk" id="element.mongodb.Chunk">
function <span class="docApiSignatureSpan">mongodb.</span>Chunk
<span class="docApiSignatureSpan">(file, mongoObject, writeConcern)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Chunk = function (file, mongoObject, writeConcern) {
  if(!(this instanceof Chunk)) return new Chunk(file, mongoObject);

  this.file = file;
  var self = this;
  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
  this.writeConcern = writeConcern || {w:1};
  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
  this.data = new Binary();

  if(mongoObjectFinal.data == null) {
  } else if(typeof mongoObjectFinal.data == "string") {
    var buffer = new Buffer(mongoObjectFinal.data.length);
    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
    this.data = new Binary(buffer);
  } else if(Array.isArray(mongoObjectFinal.data)) {
    var buffer = new Buffer(mongoObjectFinal.data.length);
    var data = mongoObjectFinal.data.join('');
    buffer.write(data, 0, data.length, 'binary');
    this.data = new Binary(buffer);
  } else if(mongoObjectFinal.data._bsontype === 'Binary') {
    this.data = mongoObjectFinal.data;
  } else if(Buffer.isBuffer(mongoObjectFinal.data)) {
  } else {
    throw Error("Illegal chunk format");
  }

  // Update position
  this.internalPosition = 0;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
 *     supported. Currently supported types for data field are instances of
 *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}
 *     from the bson module
 *
 * @see Chunk#buildMongoObject
 */
var Chunk = function(file, mongoObject, writeConcern) {
if(!(this instanceof Chunk)) return new <span class="docApiCodeKeywordSpan">Chunk</span>(file, mongoObject);

this.file = file;
var self = this;
var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
this.writeConcern = writeConcern || {w:1};
this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Code" id="element.mongodb.Code">
function <span class="docApiSignatureSpan">mongodb.</span>Code
<span class="docApiSignatureSpan">(code, scope)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope == null ? {} : scope;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    db.open(function(err, db) {
      db.createCollection('test_where', function(err, collection) {
        collection.insert([{'a':1}, {'a':2}, {'a':3}], configuration.writeConcernMax(), function(err, ids) {
          collection.count(function(err, count) {
            test.equal(3, count);

            // Let's test usage of the $where statement
            collection.find({'$where':new <span class="docApiCodeKeywordSpan">Code</span>('this.a &gt; 2')}).count(function(err, count) {
              test.equal(1, count);

              collection.find({'$where':new Code('this.a &gt; i', {i:1})}).count(function(err, count) {
test.equal(2, count);

// Let's close the db
db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection" id="element.mongodb.Collection">
function <span class="docApiSignatureSpan">mongodb.</span>Collection
<span class="docApiSignatureSpan">(db, topology, dbName, name, pkFactory, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Collection = function (db, topology, dbName, name, pkFactory, options) {
  checkCollectionName(name);
  var self = this;
  // Unpack variables
  var internalHint = null;
  var opts = options != null && ('object' === typeof options) ? options : {};
  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  var serializeFunctions = options == null || options.serializeFunctions == null ? db.serializeFunctions : options.serializeFunctions;
  var raw = options == null || options.raw == null ? db.raw : options.raw;
  var readPreference = null;
  var collectionHint = null;
  var namespace = f("%s.%s", dbName, name);

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Assign the right collection level readPreference
  if(options && options.readPreference) {
    readPreference = options.readPreference;
  } else if(db.options.readPreference) {
    readPreference = db.options.readPreference;
  }

  // Set custom primary key factory if provided
  pkFactory = pkFactory == null
    ? ObjectID
    : pkFactory;

  // Internal state
  this.s = {
    // Set custom primary key factory if provided
      pkFactory: pkFactory
    // Db
    , db: db
    // Topology
    , topology: topology
    // dbName
    , dbName: dbName
    // Options
    , options: options
    // Namespace
    , namespace: namespace
    // Read preference
    , readPreference: readPreference
    // Raw
    , raw: raw
    // SlaveOK
    , slaveOk: slaveOk
    // Serialize functions
    , serializeFunctions: serializeFunctions
    // internalHint
    , internalHint: internalHint
    // collectionHint
    , collectionHint: collectionHint
    // Name
    , name: name
    // Promise library
    , promiseLibrary: promiseLibrary
  }
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

  // Execute against admin
  self.s.db.admin().command(cmd, opt, function(err, doc) {
    if(err) return handleCallback(callback, err, null);
    // We have an error
    if(doc.errmsg) return handleCallback(callback, toError(doc), null);
    try {
      return handleCallback(callback, null, new <span class="docApiCodeKeywordSpan">Collection</span>(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
    } catch(err) {
      return handleCallback(callback, toError(err), null);
    }
  });
}

/**
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Cursor" id="element.mongodb.Cursor">
function <span class="docApiSignatureSpan">mongodb.</span>Cursor
<span class="docApiSignatureSpan">(bson, ns, cmd, options, topology, topologyOptions)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {
  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
  var self = this;
  var state = Cursor.INIT;
  var streamOptions = {};

  // Tailable cursor options
  var numberOfRetries = options.numberOfRetries || 5;
  var tailableRetryInterval = options.tailableRetryInterval || 500;
  var currentNumberOfRetries = numberOfRetries;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Set up
  Readable.call(this, {objectMode: true});

  // Internal cursor state
  this.s = {
    // Tailable cursor options
      numberOfRetries: numberOfRetries
    , tailableRetryInterval: tailableRetryInterval
    , currentNumberOfRetries: currentNumberOfRetries
    // State
    , state: state
    // Stream options
    , streamOptions: streamOptions
    // BSON
    , bson: bson
    // Namespace
    , ns: ns
    // Command
    , cmd: cmd
    // Options
    , options: options
    // Topology
    , topology: topology
    // Topology options
    , topologyOptions: topologyOptions
    // Promise library
    , promiseLibrary: promiseLibrary
    // Current doc
    , currentDoc: null
  }

  // Legacy fields
  this.timeout = self.s.options.noCursorTimeout == true;
  this.sortValue = self.s.cmd.sort;
  this.readPreference = self.s.options.readPreference;
}</pre></li>
<li>example usage<pre class="docApiCodePre">n/a</pre></li>
</ul>

<h2><a href="#element.mongodb.DBRef" id="element.mongodb.DBRef">
function <span class="docApiSignatureSpan">mongodb.</span>DBRef
<span class="docApiSignatureSpan">(namespace, oid, db)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
  
  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        db.createCollection('test_resave_dbref', function(err, collection) {
          test.equal(null, err);

          collection.insert({'name': 'parent'}, {safe : true}, function(err, r) {
            test.equal(null, err);
            test.ok(r.ops.length == 1 && r.ops[0]._id != null);
            var parent = r.ops[0];
            var child = {'name' : 'child', 'parent' : new <span class="docApiCodeKeywordSpan">DBRef</span>("test_resave_dbref",  parent._id)};

            collection.insert(child, {safe : true}, function(err, objs) {
test.equal(null, err);

collection.findOne({'name' : 'child'}, function(err, child) { //Child deserialized
  test.ok(child != null);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Db" id="element.mongodb.Db">
function <span class="docApiSignatureSpan">mongodb.</span>Db
<span class="docApiSignatureSpan">(databaseName, topology, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Db = function (databaseName, topology, options) {
  options = options || {};
  if(!(this instanceof Db)) return new Db(databaseName, topology, options);
  EventEmitter.call(this);
  var self = this;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Ensure we put the promiseLib in the options
  options.promiseLibrary = promiseLibrary;

  // var self = this;  // Internal state of the db object
  this.s = {
    // Database name
      databaseName: databaseName
    // DbCache
    , dbCache: {}
    // Children db's
    , children: []
    // Topology
    , topology: topology
    // Options
    , options: options
    // Logger instance
    , logger: Logger('Db', options)
    // Get the bson parser
    , bson: topology ? topology.bson : null
    // Authsource if any
    , authSource: options.authSource
    // Unpack read preference
    , readPreference: options.readPreference
    // Set buffermaxEntries
    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1
    // Parent db (if chained)
    , parentDb: options.parentDb || null
    // Set up the primary key factory or fallback to ObjectID
    , pkFactory: options.pkFactory || ObjectID
    // Get native parser
    , nativeParser: options.nativeParser || options.native_parser
    // Promise library
    , promiseLibrary: promiseLibrary
    // No listener
    , noListener: typeof options.noListener == 'boolean' ? options.noListener : false
  }

  // Ensure we have a valid db name
  validateDatabaseName(self.s.databaseName);

  // If we have specified the type of parser
  if(typeof self.s.nativeParser == 'boolean') {
    if(self.s.nativeParser) {
      topology.setBSONParserType("c++");
    } else {
      topology.setBSONParserType("js");
    }
  }

  // Add a read Only property
  getSingleProperty(this, 'serverConfig', self.s.topology);
  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
  getSingleProperty(this, 'databaseName', self.s.databaseName);

  // Last ismaster
  Object.defineProperty(this, 'options', {
    enumerable:true,
    get: function() { return self.s.options; }
  });

  // Last ismaster
  Object.defineProperty(this, 'native_parser', {
    enumerable:true,
    get: function() { return self.s.topology.parserType() == 'c++'; }
  });

  // Last ismaster
  Object.defineProperty(this, 'slaveOk', {
    enumerable:true,
    get: function() {
      if(self.s.options.readPreference != null
        && (self.s.options.readPreference != 'primary' || self.s.options.readPreference.mode != 'primary')) {
        return true;
      }
      return false;
    }
  });

  Object.defineProperty(this, 'writeConcern', {
    enumerable:true,
    get: function() {
      var ops = {};
      if(self.s.options.w != null) ops.w = self.s.options.w;
      if(self.s.options.j != null) ops.j = self.s.options.j;
      if(self.s.options.fsync != null) ops.fsync = self.s.options.fsync;
      if(self.s.options.wtimeout != null) ops.wtimeout = self.s.options.wtimeout;
      return ops;
    }
  });

  // This is a child db, do not register any listeners
  if(options.parentDb) return;
  if(this.s.noListener) return;

  // Add listeners
  topology.once('error', createListener(self, 'error', self));
  topology.once('timeout', createListener(self, 'timeout', self));
  topology.on('close', createListener(self, 'close', self));
  topology.once('parseError', createListener(self, 'parseError', self));
  topology.once('open', createListener(self, 'open', self));
  topology.once('fullsetup', createListener(self, 'fullsetup', self));
  topology.once('all', createListener(self, 'all', self));
  topology.on('reconnect', createListener(self, 'reconnect', self));
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
}
  },
  
  // The actual test we wish to run
  test: function(configure, test) {
var db = configure.newDbInstance({w:1}, {poolSize:1});

// DOC_LINE var db = new <span class="docApiCodeKeywordSpan">Db</span>('test', new Server('localhost', 27017));
// DOC_START
db.open(function(err, db) {
  // Some docs for insertion
  var docs = [{
      title : "this is my title", author : "bob", posted : new Date() ,
      pageViews : 5, tags : [ "fun" , "good" , "fun" ], other : { foo : 5 },
      comments : [
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Double" id="element.mongodb.Double">
function <span class="docApiSignatureSpan">mongodb.</span>Double
<span class="docApiSignatureSpan">(value)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Double(value) {
  if(!(this instanceof Double)) return new Double(value);
  
  this._bsontype = 'Double';
  this.value = value;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new Symbol("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new <span class="docApiCodeKeywordSpan">Double</span>(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new MinKey()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}

collection.insert(document, configuration.writeConcernMax(), function(err, result) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.GridStore" id="element.mongodb.GridStore">
function <span class="docApiSignatureSpan">mongodb.</span>GridStore
<span class="docApiSignatureSpan">(db, id, filename, mode, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function GridStore(db, id, filename, mode, options) {
  if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
  var self = this;
  this.db = db;

  // Handle options
  if(typeof options === 'undefined') options = {};
  // Handle mode
  if(typeof mode === 'undefined') {
    mode = filename;
    filename = undefined;
  } else if(typeof mode == 'object') {
    options = mode;
    mode = filename;
    filename = undefined;
  }

  if(id instanceof ObjectID) {
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  } else if(typeof filename == 'undefined') {
    this.referenceBy = REFERENCE_BY_FILENAME;
    this.filename = id;
    if (mode.indexOf('w') != null) {
      this.fileId = new ObjectID();
    }
  } else {
    this.referenceBy = REFERENCE_BY_ID;
    this.fileId = id;
    this.filename = filename;
  }

  // Set up the rest
  this.mode = mode == null ? "r" : mode;
  this.options = options || {};

  // Opened
  this.isOpen = false;

  // Set the root if overridden
  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
  this.position = 0;
  this.readPreference = this.options.readPreference || ReadPreference.PRIMARY;
  this.writeConcern = _getWriteConcern(db, this.options);
  // Set default chunk size
  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];

  // Get the promiseLibrary
  var promiseLibrary = this.options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Set the promiseLibrary
  this.promiseLibrary = promiseLibrary;

  Object.defineProperty(this, "chunkSize", { enumerable: true
   , get: function () {
       return this.internalChunkSize;
     }
   , set: function(value) {
       if(!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) {
         this.internalChunkSize = this.internalChunkSize;
       } else {
         this.internalChunkSize = value;
       }
     }
  });

  Object.defineProperty(this, "md5", { enumerable: true
   , get: function () {
       return this.internalMd5;
     }
  });

  Object.defineProperty(this, "chunkNumber", { enumerable: true
   , get: function () {
       return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
     }
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
var gs1
  , gs2
  , id = new ObjectID()
  , filename = 'test_create_gridstore';

var gs = new <span class="docApiCodeKeywordSpan">GridStore</span>(db, id, filename, "w");
test.ok(gs instanceof GridStore);
test.equal(id, gs.fileId);
test.equal(filename, gs.filename);

var gs = GridStore(db, id, filename, "w");
test.ok(gs instanceof GridStore);
test.equal(id, gs.fileId);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Logger" id="element.mongodb.Logger">
function <span class="docApiSignatureSpan">mongodb.</span>Logger
<span class="docApiSignatureSpan">(className, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Logger = function (className, options) {
  if(!(this instanceof Logger)) return new Logger(className, options);
  options = options || {};

  // Current reference
  var self = this;
  this.className = className;

  // Current logger
  if(currentLogger == null && options.logger) {
    currentLogger = options.logger;
  } else if(currentLogger == null) {
    currentLogger = console.log;
  }

  // Set level of logging, default is error
  if(level == null) {
    level = options.loggerLevel || 'error';
  }

  // Add all class names
  if(filteredClasses[this.className] == null) classFilters[this.className] =  true;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
// Children db's
, children: []
// Topology
, topology: topology
// Options
, options: options
// Logger instance
, logger: <span class="docApiCodeKeywordSpan">Logger</span>('Db', options)
// Get the bson parser
, bson: topology ? topology.bson : null
// Authsource if any
, authSource: options.authSource
// Unpack read preference
, readPreference: options.readPreference
// Set buffermaxEntries
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Long" id="element.mongodb.Long">
function <span class="docApiSignatureSpan">mongodb.</span>Long
<span class="docApiSignatureSpan">(low, high)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);
  
  this._bsontype = 'Long';
<span class="docApiCodeCommentSpan">  /**
   * @type {number}
   * @api private
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

// Unpack the cursor
var lowBits = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;
var highBits = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;
// Create long object
this.cursorId = new <span class="docApiCodeKeywordSpan">Long</span>(lowBits, highBits);

// Unpack the starting from
this.startingFrom = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;

// Unpack the number of objects returned
this.numberReturned = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
...</pre></li>
</ul>

<h2><a href="#element.mongodb.MaxKey" id="element.mongodb.MaxKey">
function <span class="docApiSignatureSpan">mongodb.</span>MaxKey
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();
  
  this._bsontype = 'MaxKey';  
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

      var document = {
  "symbol": new Symbol("abcdefghijkl")
, "objid": new ObjectID("abcdefghijkl")
, "double": new Double(1)
, "binary": new Binary(new Buffer("hello world"))
, "minkey": new MinKey()
, "maxkey": new <span class="docApiCodeKeywordSpan">MaxKey</span>()
, "code": new Code("function () {}", {a: 55})
      }

      collection.insert(document, configuration.writeConcernMax(), function(err, result) {
test.equal(null, err);

collection.findOne({"symbol": new Symbol("abcdefghijkl")}, function(err, doc) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.MinKey" id="element.mongodb.MinKey">
function <span class="docApiSignatureSpan">mongodb.</span>MinKey
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();
  
  this._bsontype = 'MinKey';
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new Symbol("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new Double(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new <span class="docApiCodeKeywordSpan">MinKey</span>()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}

collection.insert(document, configuration.writeConcernMax(), function(err, result) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.MongoClient" id="element.mongodb.MongoClient">
function <span class="docApiSignatureSpan">mongodb.</span>MongoClient
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MongoClient() {
<span class="docApiCodeCommentSpan">  /**
   * The callback format for results
   * @callback MongoClient~connectCallback
   * @param {MongoError} error An error instance representing the error during the execution.
   * @param {Db} db The connected database.
   */
</span>
  /**
   * Connect to MongoDB using a url as documented at
   *
   *  docs.mongodb.org/manual/reference/connection-string/
   *
   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
   *
   * @method
   * @param {string} url The connection URI string
   * @param {object} [options=null] Optional settings.
   * @param {boolean} [options.uri_decode_auth=false] Uri decode the user name and password for authentication
   * @param {object} [options.db=null] A hash of options to set on the db object, see **Db constructor**
   * @param {object} [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
   * @param {object} [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
   * @param {object} [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
   * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
   * @param {MongoClient~connectCallback} [callback] The command result callback
   * @return {Promise} returns Promise if no callback passed
   */
  this.connect = MongoClient.connect;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
 */

/**
 * Creates a new MongoClient instance
 * @class
 * @return {MongoClient} a MongoClient instance.
 */
function <span class="docApiCodeKeywordSpan">MongoClient</span>() {
/**
 * The callback format for results
 * @callback MongoClient~connectCallback
 * @param {MongoError} error An error instance representing the error during the execution.
 * @param {Db} db The connected database.
 */
...</pre></li>
</ul>

<h2><a href="#element.mongodb.MongoError" id="element.mongodb.MongoError">
function <span class="docApiSignatureSpan">mongodb.</span>MongoError
<span class="docApiSignatureSpan">(message)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MongoError(message) {
  this.name = 'MongoError';
  this.message = message;
  Error.captureStackTrace(this, MongoError);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
/**
* Set the current logger function
* @method
* @param {function} logger Logger function.
* @return {null}
*/
Logger.setCurrentLogger = function(logger) {
 if(typeof logger != 'function') throw new <span class="docApiCodeKeywordSpan">MongoError</span>("current logger must be a function");
 currentLogger = logger;
}

/**
* Set what classes to log.
* @method
* @param {string} type The type of filter (currently only class)
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Mongos" id="element.mongodb.Mongos">
function <span class="docApiSignatureSpan">mongodb.</span>Mongos
<span class="docApiSignatureSpan">(servers, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Mongos = function (servers, options) {
  if(!(this instanceof Mongos)) return new Mongos(servers, options);
  options = options || {};
  var self = this;

  // Ensure all the instances are Server
  for(var i = 0; i &lt; servers.length; i++) {
    if(!(servers[i] instanceof Server)) {
      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
    }
  }

  // Store option defaults
  var storeOptions = {
      force: false
    , bufferMaxEntries: -1
  }

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Set up event emitter
  EventEmitter.call(this);

  // Debug tag
  var tag = options.tag;

  // Build seed list
  var seedlist = servers.map(function(x) {
    return {host: x.host, port: x.port}
  });

  // Final options
  var finalOptions = shallowClone(options);

  // Default values
  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;
  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
  finalOptions.cursorFactory = Cursor;

  // Add the store
  finalOptions.disconnectHandler = store;

  // Ensure we change the sslCA option to ca if available
  if(options.sslCA) finalOptions.ca = options.sslCA;
  if(typeof options.sslValidate == 'boolean') finalOptions.rejectUnauthorized = options.sslValidate;
  if(options.sslKey) finalOptions.key = options.sslKey;
  if(options.sslCert) finalOptions.cert = options.sslCert;
  if(options.sslPass) finalOptions.passphrase = options.sslPass;

  // Socket options passed down
  if(options.socketOptions) {
    if(options.socketOptions.connectTimeoutMS) {
      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
    }
    if(options.socketOptions.socketTimeoutMS)
      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
  }

  // Are we running in debug mode
  var debug = typeof options.debug == 'boolean' ? options.debug : false;
  if(debug) {
    finalOptions.debug = debug;
  }

  // Map keep alive setting
  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
    finalOptions.keepAlive = true;
    if(typeof options.socketOptions.keepAlive == 'number') {
      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
    }
  }

  // Connection timeout
  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
  }

  // Socket timeout
  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
  }

  // noDelay
  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
    finalOptions.noDelay = options.socketOptions.noDelay;
  }

  if(typeof options.secondaryAcceptableLatencyMS == 'number') {
    finalOptions.acceptableLatency = options.secondaryAcceptableLatencyMS;
  }

  // Add the non connection store
  finalOptions.disconnectHandler = store;

  // Create the Mongos
  var mongos = new CMongos(seedlist, finalOptions)
  // Server capabilities
  var sCapabilities = null;
  // Add auth prbufferMaxEntriesoviders
  mongos.addAuthProvider('mongocr', new MongoCR());

  // Internal state
  this.s = {
    // Create the Mongos
      mongos: mongos
    // Server capabilities
    , sCapabilities: sCapabilities
    // Debug turned on
    , debug: debug
    // Store option defaults
    , storeOptions: storeOptions
    // Cloned options
    , clonedOptions: finalOptions
    // Actual store of callbacks
    , store: store
    // Options
    , options: options
  }


  // Last ismaster
  Object.defineProperty(this, 'isMasterDoc', {
    enumerable:true, get: function() { return self.s.mongos.lastIsMaster(); }
  });

  // Last ismaster
  Object.defineProperty(this, 'numberOfConnectedServers', ...</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var MongoClient = configuration.require.MongoClient
, Db = configuration.require.Db
, Server = configuration.require.Server
, Mongos = configuration.require.Mongos;

    setUpSharded(configuration, function(err) {
var mongos = new <span class="docApiCodeKeywordSpan">Mongos</span>([
    new Server( 'localhost', shardedManager.mongosStartPort),
  ], {poolSize: 1});

var db = new Db('node-native-test', mongos, {w:1});
db.open(function(err, p_db) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.ObjectID" id="element.mongodb.ObjectID">
function <span class="docApiSignatureSpan">mongodb.</span>ObjectID
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function ObjectID(id, _hex) {
  if(!(this instanceof ObjectID)) return new ObjectID(id, _hex);

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24))
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  // Generate id based on the input
  if(id == null || typeof id == 'number') {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null && id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(checkForHexRegExp.test(id)) {
    return ObjectID.createFromHexString(id);
  } else {
    throw new Error("Value passed in is not a valid 24 character hex string");
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // The actual test we wish to run
  test: function(configuration, test) {
    var ObjectID = configuration.require.ObjectID;

    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_should_correctly_do_update_with_no_docs', function(err, collection) {
        var id = new <span class="docApiCodeKeywordSpan">ObjectID</span>(null)
        var doc = {_id:id, a:1};

        collection.update({"_id":id}, doc, configuration.writeConcernMax(), function(err, r) {
test.equal(null, err);
test.equal(0, r.result.n);

db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.ObjectId" id="element.mongodb.ObjectId">
function <span class="docApiSignatureSpan">mongodb.</span>ObjectId
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function ObjectID(id, _hex) {
  if(!(this instanceof ObjectID)) return new ObjectID(id, _hex);

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24))
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  // Generate id based on the input
  if(id == null || typeof id == 'number') {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null && id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(checkForHexRegExp.test(id)) {
    return ObjectID.createFromHexString(id);
  } else {
    throw new Error("Value passed in is not a valid 24 character hex string");
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
<li>example usage<pre class="docApiCodePre">n/a</pre></li>
</ul>

<h2><a href="#element.mongodb.ReadPreference" id="element.mongodb.ReadPreference">
function <span class="docApiSignatureSpan">mongodb.</span>ReadPreference
<span class="docApiSignatureSpan">(mode, tags)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ReadPreference = function (mode, tags) {
  if(!(this instanceof ReadPreference))
    return new ReadPreference(mode, tags);
  this._type = 'ReadPreference';
  this.mode = mode;
  this.tags = tags;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
}

if(joined &gt;= Object.keys(left).length) {
  db.collection('replset_insert0').insert({a:1}, function(err, result) {
    test.equal(null, err);

    db.command({ismaster:true}
      , {readPreference: new <span class="docApiCodeKeywordSpan">ReadPreference</span>('secondary')}
      , function(err, result) {
        test.equal(null, err);
        db.close();
        restartAndDone(configuration, test);
      });
  });
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.ReplSet" id="element.mongodb.ReplSet">
function <span class="docApiSignatureSpan">mongodb.</span>ReplSet
<span class="docApiSignatureSpan">(servers, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ReplSet = function (servers, options) {
  if(!(this instanceof ReplSet)) return new ReplSet(servers, options);
  options = options || {};
  var self = this;

  // Ensure all the instances are Server
  for(var i = 0; i &lt; servers.length; i++) {
    if(!(servers[i] instanceof Server)) {
      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
    }
  }

  // Store option defaults
  var storeOptions = {
      force: false
    , bufferMaxEntries: -1
  }

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Set up event emitter
  EventEmitter.call(this);

  // Debug tag
  var tag = options.tag;

  // Build seed list
  var seedlist = servers.map(function(x) {
    return {host: x.host, port: x.port}
  });

  // Final options
  var finalOptions = shallowClone(options);

  // Default values
  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;
  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
  finalOptions.cursorFactory = Cursor;

  // Add the store
  finalOptions.disconnectHandler = store;

  // Socket options passed down
  if(options.socketOptions) {
    if(options.socketOptions.connectTimeoutMS) {
      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
    }

    if(options.socketOptions.socketTimeoutMS) {
      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
    }
  }

  // Get the name
  var replicaSet = options.replicaSet || options.rs_name;

  // Set up options
  finalOptions.setName = replicaSet;

  // Are we running in debug mode
  var debug = typeof options.debug == 'boolean' ? options.debug : false;
  if(debug) {
    finalOptions.debug = debug;
  }

  // Map keep alive setting
  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
    finalOptions.keepAlive = true;
    if(typeof options.socketOptions.keepAlive == 'number') {
      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
    }
  }

  // Connection timeout
  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
  }

  // Socket timeout
  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
  }

  // noDelay
  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
    finalOptions.noDelay = options.socketOptions.noDelay;
  }

  if(typeof options.secondaryAcceptableLatencyMS == 'number') {
    finalOptions.acceptableLatency = options.secondaryAcceptableLatencyMS;
  }

  if(options.connectWithNoPrimary == true) {
    finalOptions.secondaryOnlyConnectionAllowed = true;
  }

  // Add the non connection store
  finalOptions.disconnectHandler = store;

  // Translate the options
  if(options.sslCA) finalOptions.ca = options.sslCA;
  if(typeof options.sslValidate == 'boolean') finalOptions.rejectUnauthorized = options.sslValidate;
  if(options.sslKey) finalOptions.key = options.sslKey;
  if(options.sslCert) finalOptions.cert = options.sslCert;
  if(options.sslPass) finalOptions.passphrase = options.sslPass;

  // Create the ReplSet
  var replset = new CReplSet(seedlist, finalOptions)
  // Server capabilities
  var sCapabilities = null;
  // Add auth prbufferMaxEntriesoviders
  replset.addAuthProvider('mongocr', new MongoCR());

  // Listen to reconnect event
  replset.on('reconnect', function() {
    self.emit('reconnect');
    store.execute();
  });

  // Internal state
  this.s = {
    // Replicaset
    replset: replset
    // Server capabilities
    , sCapabilities: null
    // Debug tag
    , tag: options.tag
    // Store options
    , storeOptions: storeOptions
    // Cloned options
    , clonedOptions: finalOptions ...</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // The actual test we wish to run
  test: function(configuration, test) {
    var Db = configuration.require.Db
, Server = configuration.require.Server
, ReplSet = configuration.require.ReplSet;

    setUp(configuration, function(err) {
var replSet = new <span class="docApiCodeKeywordSpan">ReplSet</span>( [
    new Server( 'localhost', replSetManager.startPort),
    new Server( 'localhost', replSetManager.startPort + 1)
  ],
  {rs_name: replSetManager.replicasetName, poolSize:1}
);

// Connect
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Server" id="element.mongodb.Server">
function <span class="docApiSignatureSpan">mongodb.</span>Server
<span class="docApiSignatureSpan">(host, port, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Server = function (host, port, options) {
  options = options || {};
  if(!(this instanceof Server)) return new Server(host, port, options);
  EventEmitter.call(this);
  var self = this;

  // Store option defaults
  var storeOptions = {
      force: false
    , bufferMaxEntries: -1
  }

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Detect if we have a socket connection
  if(host.indexOf('\/') != -1) {
    if(port != null && typeof port == 'object') {
      options = port;
      port = null;
    }
  } else if(port == null) {
    throw MongoError.create({message: 'port must be specified', driver:true});
  }

  // Clone options
  var clonedOptions = shallowClone(options);
  clonedOptions.host = host;
  clonedOptions.port = port;

  // Reconnect
  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
  var emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
  var poolSize = typeof options.poolSize == 'number' ? options.poolSize : 5;

  // Socket options passed down
  if(options.socketOptions) {
    if(options.socketOptions.connectTimeoutMS) {
      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
      clonedOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
    }

    if(options.socketOptions.socketTimeoutMS) {
      clonedOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
    }

    if(typeof options.socketOptions.keepAlive == 'number') {
      clonedOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
      clonedOptions.keepAlive = true;
    }

    if(typeof options.socketOptions.noDelay == 'boolean') {
      clonedOptions.noDelay = options.socketOptions.noDelay;
    }
  }

  // Add the cursor factory function
  clonedOptions.cursorFactory = Cursor;
  clonedOptions.reconnect = reconnect;
  clonedOptions.emitError = emitError;
  clonedOptions.size = poolSize;

  // Translate the options
  if(clonedOptions.sslCA) clonedOptions.ca = clonedOptions.sslCA;
  if(typeof clonedOptions.sslValidate == 'boolean') clonedOptions.rejectUnauthorized = clonedOptions.sslValidate;
  if(clonedOptions.sslKey) clonedOptions.key = clonedOptions.sslKey;
  if(clonedOptions.sslCert) clonedOptions.cert = clonedOptions.sslCert;
  if(clonedOptions.sslPass) clonedOptions.passphrase = clonedOptions.sslPass;

  // Add the non connection store
  clonedOptions.disconnectHandler = store;

  // Create an instance of a server instance from mongodb-core
  var server = new CServer(clonedOptions);
  // Server capabilities
  var sCapabilities = null;

  // Define the internal properties
  this.s = {
    // Create an instance of a server instance from mongodb-core
      server: server
    // Server capabilities
    , sCapabilities: null
    // Cloned options
    , clonedOptions: clonedOptions
    // Reconnect
    , reconnect: reconnect
    // Emit error
    , emitError: emitError
    // Pool size
    , poolSize: poolSize
    // Store Options
    , storeOptions: storeOptions
    // Store
    , store: store
    // Host
    , host: host
    // Port
    , port: port
    // Options
    , options: options
  }

  // BSON property
  Object.defineProperty(this, 'bson', {
    enumerable: true, get: function() {
      return self.s.server.bson;
    }
  });

  // Last ismaster
  Object.defineProperty(this, 'isMasterDoc', {
    enumerable:true, get: function() {
      return self.s.server.lastIsMaster();
    }
  });

  // Last ismaster
  Object.defineProperty(this, 'poolSize', {
    enumerable:true, get: function() { return self.s.server.connections().length; }
  });

  Object.defineProperty(this, 'autoReconnect', {
    enumerable:true, get: function() { return self.s.reconnect; }
  });

  Object.defineProperty(this, 'host', {
    enumerable:true, get: function() { return self.s.host; }
  });

  Object.defineProperty(this, 'port', {
    enumerable:true, get: function() { return self.s.port; }
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
}
  },
  
  // The actual test we wish to run
  test: function(configure, test) {
var db = configure.newDbInstance({w:1}, {poolSize:1});

// DOC_LINE var db = new Db('test', new <span class="docApiCodeKeywordSpan">Server</span>('localhost', 27017));
// DOC_START
db.open(function(err, db) {
  // Some docs for insertion
  var docs = [{
      title : "this is my title", author : "bob", posted : new Date() ,
      pageViews : 5, tags : [ "fun" , "good" , "fun" ], other : { foo : 5 },
      comments : [
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Symbol" id="element.mongodb.Symbol">
function <span class="docApiSignatureSpan">mongodb.</span>Symbol
<span class="docApiSignatureSpan">(value)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
, Code = configuration.require.Code;

    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new <span class="docApiCodeKeywordSpan">Symbol</span>("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new Double(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new MinKey()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Timestamp" id="element.mongodb.Timestamp">
function <span class="docApiSignatureSpan">mongodb.</span>Timestamp
<span class="docApiSignatureSpan">(low, high)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
<span class="docApiCodeCommentSpan">  /**
   * @type {number}
   * @api private
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
var ObjectID = configuration.require.ObjectID
  , Timestamp = configuration.require.Timestamp;

var doc = {
 "_id" : new ObjectID("4e886e687ff7ef5e00000162"),
 "str" : "foreign",
 "type" : 2,
 "timestamp" : new <span class="docApiCodeKeywordSpan">Timestamp</span>(10000),
 "links" : [
   "http://www.reddit.com/r/worldnews/comments/kybm0/uk_home_secretary_calls_for_the_scrapping_of_the/"
 ],
 "timestamp2" : new Timestamp(33333),
}

var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.connect" id="element.mongodb.connect">
function <span class="docApiSignatureSpan">mongodb.</span>connect
<span class="docApiSignatureSpan">(url, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">connect = function (url, options, callback) {
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
  options = args.length ? args.shift() : null;
  options = options || {};

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Return a promise
  if(typeof callback != 'function') {
    return new promiseLibrary(function(resolve, reject) {
      connect(url, options, function(err, db) {
        if(err) return reject(err);
        resolve(db);
      });
    });
  }

  // Fallback to callback based connect
  connect(url, options, callback);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
modeNext = error
    ? Infinity
    : modeNext + 1;
console.log('step ' + modeNext);
switch (modeNext) {
case 1:
    console.log('connecting to mongodb server');
    local.mongodb.MongoClient.<span class="docApiCodeKeywordSpan">connect</span>(
        'mongodb://localhost:27017/test',
        onNext
    );
    break;
case 2:
    local.db = data;
    console.log('connected to mongodb server');
...</pre></li>
</ul>

</div>

<div class="docApiSectionDiv">
<h1><a href="#module.mongodb.Collection" id="module.mongodb.Collection">module mongodb.Collection</a></h1>

<h2><a href="#element.mongodb.Collection.aggregate" id="element.mongodb.Collection.aggregate">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>aggregate
<span class="docApiSignatureSpan">(pipeline, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">aggregate = function (pipeline, options, callback) {
  var self = this;
  if(Array.isArray(pipeline)) {
    // Set up callback if one is provided
    if(typeof options == 'function') {
      callback = options;
      options = {};
    }

    // If we have no options or callback we are doing
    // a cursor based aggregation
    if(options == null && callback == null) {
      options = {};
    }
  } else {
    // Aggregation pipeline passed as arguments on the method
    var args = Array.prototype.slice.call(arguments, 0);
    // Get the callback
    callback = args.pop();
    // Get the possible options object
    var opts = args[args.length - 1];
    // If it contains any of the admissible options pop it of the args
    options = opts && (opts.readPreference
      || opts.explain || opts.cursor || opts.out
      || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {};
      // Left over arguments is the pipeline
    pipeline = args;
  }

  // If out was specified
  if(typeof options.out == 'string') {
    pipeline.push({$out: options.out});
  }

  // Build the command
  var command = { aggregate : this.s.name, pipeline : pipeline};
  // If we have allowDiskUse defined
  if(options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
  if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;

  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // If explain has been specified add it
  if(options.explain) command.explain = options.explain;

  // Validate that cursor options is valid
  if(options.cursor != null && typeof options.cursor != 'object') {
    throw toError('cursor options must be an object');
  }

  // promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Set the AggregationCursor constructor
  options.cursorFactory = AggregationCursor;
  if(typeof callback != 'function') {
    if(this.s.topology.capabilities().hasAggregationCursor) {
      options.cursor = options.cursor || { batchSize : 1000 };
      command.cursor = options.cursor;
    }

    // Allow disk usage command
    if(typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
    if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;

    // Execute the cursor
    return this.s.topology.cursor(this.s.namespace, command, options);
  }

  var cursor = null;
  // We do not allow cursor
  if(options.cursor) {
    return this.s.topology.cursor(this.s.namespace, command, options);
  }

  // Execute the command
  this.s.db.command(command, options, function(err, result) {
    if(err) {
      handleCallback(callback, err);
    } else if(result['err'] || result['errmsg']) {
      handleCallback(callback, toError(result));
    } else if(typeof result == 'object' && result['serverPipeline']) {
      handleCallback(callback, null, result['serverPipeline']);
    } else if(typeof result == 'object' && result['stages']) {
      handleCallback(callback, null, result['stages']);
    } else {
      handleCallback(callback, null, result.result);
    }
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
      col.remove({}, function() {
        // Insert a single document
        col.insert([{a:1}, {a:1}, {a:1}], function(err, r) {
test.equal(null, err);
test.equal(3, r.result.n);

// Get first two documents that match the query
col.<span class="docApiCodeKeywordSpan">aggregate</span>([
      {$match: {}}
    , {$group:
        {_id: '$a', total: {$sum: '$a'} }
      }
  ]).toArray(function(err, docs) {
  test.equal(null, err);
  test.equal(3, docs[0].total);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.bulkWrite" id="element.mongodb.Collection.bulkWrite">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>bulkWrite
<span class="docApiSignatureSpan">(operations, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">bulkWrite = function (operations, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {ordered:true};

  if(!Array.isArray(operations)) {
    throw MongoError.create({message: "operations must be an array of documents", driver:true });
  }

  // Execute using callback
  if(typeof callback == 'function') return bulkWrite(self, operations, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    bulkWrite(self, operations, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
// LINE   test = require('assert');
// LINE MongoClient.connect('mongodb://localhost:27017/test', function(err, db) {
// REPLACE configuration.writeConcernMax() WITH {w:1}
// REMOVE-LINE test.done();
// BEGIN
  // Get the collection
  var col = db.collection('bulk_write');
  col.<span class="docApiCodeKeywordSpan">bulkWrite</span>([
      { insertOne: { document: { a: 1 } } }
    , { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
    , { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
    , { deleteOne: { filter: {c:1} } }
    , { deleteMany: { filter: {c:1} } }
    , { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}]
  , {ordered:true, w:1}, function(err, r) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.count" id="element.mongodb.Collection.count">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>count
<span class="docApiSignatureSpan">(query, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">count = function (query, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  var queryOption = args.length ? args.shift() || {} : {};
  var optionsOption = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return count(self, queryOption, optionsOption, callback);

  // Check if query is empty
  query = query || {};
  options = options || {};

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    count(self, query, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
metadata: { requires: { topology: ['single', 'replicaset', 'sharded', 'ssl', 'heap', 'wiredtiger'] } },

// The actual test we wish to run
test: function(configuration, test) {
  var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
  db.open(function(err, db) {
    db.collection('test_multiple_insert_2', function(err, collection) {
      collection.<span class="docApiCodeKeywordSpan">count</span>(function(err, count) {
        test.equal(0, count);
        // Let's close the db
        db.close();
        test.done();
      });
    });
  });
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.createIndex" id="element.mongodb.Collection.createIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>createIndex
<span class="docApiSignatureSpan">(fieldOrSpec, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">createIndex = function (fieldOrSpec, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || {} : {};
  options = typeof callback === 'function' ? options : callback;
  options = options == null ? {} : options;

  // Execute using callback
  if(typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    createIndex(self, fieldOrSpec, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {native_parser:false})
    db.open(function(err, db) {
      // Get collection
      var col = db.collection('insertManyMultipleWriteErrors');
      col.drop(function(err, r) {

        // Create unique index
        col.<span class="docApiCodeKeywordSpan">createIndex</span>({a:1}, {unique:true}, function(err, r) {
          test.equal(null, err);

          col.insertMany([{a:1}, {a:2}, {a:1}, {a:3}, {a:1}], {ordered:false}, function(err, r) {
test.ok(err != null);
test.ok(err.writeErrors.length == 2);

db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.createIndexes" id="element.mongodb.Collection.createIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>createIndexes
<span class="docApiSignatureSpan">(indexSpecs, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">createIndexes = function (indexSpecs, callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return createIndexes(self, indexSpecs, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    createIndexes(self, indexSpecs, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
exports['should correctly execute createIndexes'] = {
  metadata: { requires: { mongodb: "&gt;=2.6.0", topology: ['single', 'ssl', 'heap', 'wiredtiger'] } },

  // The actual test we wish to run
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.collection('createIndexes').<span class="docApiCodeKeywordSpan">createIndexes</span>([
{ key: {a:1} }, { key: {b:1}, name: "hello1"}
      ], function(err, r) {
test.equal(null, err);
test.equal(3, r.numIndexesAfter)

db.collection('createIndexes').listIndexes().toArray(function(err, docs) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.deleteMany" id="element.mongodb.Collection.deleteMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>deleteMany
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">deleteMany = function (filter, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  var options = shallowClone(options);

  // Execute using callback
  if(typeof callback == 'function') return deleteMany(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    deleteMany(self, filter, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
test.equal(null, err);
test.equal(1, result.result.ok);

col.deleteOne({a:1}, {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);

  col.<span class="docApiCodeKeywordSpan">deleteMany</span>({a:1}, {w:0}, function(err, result) {
    test.equal(null, err);
    test.equal(1, result.result.ok);

    db.close();
    test.done();
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.deleteOne" id="element.mongodb.Collection.deleteOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>deleteOne
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">deleteOne = function (filter, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  var options = shallowClone(options);

  // Execute using callback
  if(typeof callback == 'function') return deleteOne(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    deleteOne(self, filter, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
            test.equal(null, err);
            test.equal(1, result.result.ok);

            col.updateMany({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
              test.equal(null, err);
              test.equal(1, result.result.ok);

              col.<span class="docApiCodeKeywordSpan">deleteOne</span>({a:1}, {w:0}, function(err, result) {
test.equal(null, err);
test.equal(1, result.result.ok);

col.deleteMany({a:1}, {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.distinct" id="element.mongodb.Collection.distinct">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>distinct
<span class="docApiSignatureSpan">(key, query, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">distinct = function (key, query, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  var queryOption = args.length ? args.shift() || {} : {};
  var optionsOption = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback);

  // Ensure the query and options are set
  query = query || {};
  options = options || {};

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    distinct(self, key, query, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_distinct_queries', function(err, collection) {
        collection.insert([{'a':0, 'b':{'c':'a'}},
          {'a':1, 'b':{'c':'b'}},
          {'a':1, 'b':{'c':'c'}},
          {'a':2, 'b':{'c':'a'}}, {'a':3}, {'a':3}], configuration.writeConcernMax(), function(err, ids) {
collection.<span class="docApiCodeKeywordSpan">distinct</span>('a', function(err, docs) {
  test.deepEqual([0, 1, 2, 3], docs.sort());
});

collection.distinct('b.c', function(err, docs) {
  test.deepEqual(['a', 'b', 'c'], docs.sort());
  db.close();
  test.done();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.drop" id="element.mongodb.Collection.drop">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>drop
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">drop = function (callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return self.s.db.dropCollection(self.s.name, callback);
  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    self.s.db.dropCollection(self.s.name, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

  // The actual test we wish to run
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {native_parser:false})
    db.open(function(err, db) {
      // Get collection
      var col = db.collection('insertManyMultipleWriteErrors');
      col.<span class="docApiCodeKeywordSpan">drop</span>(function(err, r) {

        // Create unique index
        col.createIndex({a:1}, {unique:true}, function(err, r) {
test.equal(null, err);

col.insertMany([{a:1}, {a:2}, {a:1}, {a:3}, {a:1}], {ordered:false}, function(err, r) {
  test.ok(err != null);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.dropAllIndexes" id="element.mongodb.Collection.dropAllIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropAllIndexes
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">dropAllIndexes = function (callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return dropIndexes(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    dropIndexes(self, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    db.open(function(err, db) {
      db.createCollection('test_drop_indexes', function(err, collection) {
        collection.insert({a:1}, configuration.writeConcernMax(), function(err, ids) {
          // Create an index on the collection
          db.createIndex(collection.collectionName, 'a', configuration.writeConcernMax(), function(err, indexName) {
            test.equal("a_1", indexName);
            // Drop all the indexes
            collection.<span class="docApiCodeKeywordSpan">dropAllIndexes</span>(function(err, result) {
test.equal(true, result);

collection.indexInformation(function(err, result) {
  test.ok(result['a_1'] == null);
  db.close();
  test.done();
})
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.dropIndex" id="element.mongodb.Collection.dropIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropIndex
<span class="docApiSignatureSpan">(indexName, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">dropIndex = function (indexName, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || {} : {};
  // Run only against primary
  options.readPreference = ReadPreference.PRIMARY;

  // Execute using callback
  if(typeof callback == 'function') return dropIndex(self, indexName, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    dropIndex(self, indexName, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
  db.open(function(err, db) {
    var collection = db.collection("should_correctly_drop_index");
    collection.insert([{a:1}], configuration.writeConcernMax(), function(err, result) {
      test.equal(null, err);

      collection.ensureIndex({a:1}, configuration.writeConcernMax(), function(err, result) {
        collection.<span class="docApiCodeKeywordSpan">dropIndex</span>("a_1")

        db.close();
        test.done();
      });
    });
  });
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.dropIndexes" id="element.mongodb.Collection.dropIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>dropIndexes
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">dropIndexes = function (callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return dropIndexes(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    dropIndexes(self, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">n/a</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.ensureIndex" id="element.mongodb.Collection.ensureIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>ensureIndex
<span class="docApiSignatureSpan">(fieldOrSpec, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ensureIndex = function (fieldOrSpec, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    ensureIndex(self, fieldOrSpec, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var db = configuration.newDbInstance({w:1}, {poolSize:1, auto_reconnect:false});
    db.open(function(err, db) {
      // Get the collection
      var col = db.collection('batch_write_ordered_ops_1');

      // Add unique index on b field causing all updates to fail
      col.<span class="docApiCodeKeywordSpan">ensureIndex</span>({a:1}, {unique:true, sparse:false}, function(err, result) {
test.equal(err, null);

// Initialize the Ordered Batch
var batch = col.initializeOrderedBulkOp();

// Add some operations to be executed in order
batch.insert({b:1, a:1});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.find" id="element.mongodb.Collection.find">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>find
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">find = function () {
  var options
    , args = Array.prototype.slice.call(arguments, 0)
    , has_callback = typeof args[args.length - 1] === 'function'
    , has_weird_callback = typeof args[0] === 'function'
    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)
    , len = args.length
    , selector = len &gt;= 1 ? args[0] : {}
    , fields = len &gt;= 2 ? args[1] : undefined;

  if(len === 1 && has_weird_callback) {
    // backwards compat for callback?, options case
    selector = {};
    options = args[0];
  }

  if(len === 2 && fields !== undefined && !Array.isArray(fields)) {
    var fieldKeys = Object.keys(fields);
    var is_option = false;

    for(var i = 0; i &lt; fieldKeys.length; i++) {
      if(testForFields[fieldKeys[i]] != null) {
        is_option = true;
        break;
      }
    }

    if(is_option) {
      options = fields;
      fields = undefined;
    } else {
      options = {};
    }
  } else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {
    var newFields = {};
    // Rewrite the array
    for(var i = 0; i &lt; fields.length; i++) {
      newFields[fields[i]] = 1;
    }
    // Set the fields
    fields = newFields;
  }

  if(3 === len) {
    options = args[2];
  }

  // Ensure selector is not null
  selector = selector == null ? {} : selector;
  // Validate correctness off the selector
  var object = selector;
  if(Buffer.isBuffer(object)) {
    var object_size = object[0] | object[1] &lt;&lt; 8 | object[2] &lt;&lt; 16 | object[3] &lt;&lt; 24;
    if(object_size != object.length)  {
      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
      error.name = 'MongoError';
      throw error;
    }
  }

  // Validate correctness of the field selector
  var object = fields;
  if(Buffer.isBuffer(object)) {
    var object_size = object[0] | object[1] &lt;&lt; 8 | object[2] &lt;&lt; 16 | object[3] &lt;&lt; 24;
    if(object_size != object.length)  {
      var error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
      error.name = 'MongoError';
      throw error;
    }
  }

  // Check special case where we are using an objectId
  if(selector instanceof ObjectID || (selector != null && selector._bsontype == 'ObjectID')) {
    selector = {_id:selector};
  }

  // If it's a serialized fields field we need to just let it through
  // user be warned it better be good
  if(options && options.fields && !(Buffer.isBuffer(options.fields))) {
    fields = {};

    if(Array.isArray(options.fields)) {
      if(!options.fields.length) {
        fields['_id'] = 1;
      } else {
        for (var i = 0, l = options.fields.length; i &lt; l; i++) {
          fields[options.fields[i]] = 1;
        }
      }
    } else {
      fields = options.fields;
    }
  }

  if (!options) options = {};

  var newOptions = {};
  // Make a shallow copy of options
  for (var key in options) {
    newOptions[key] = options[key];
  }

  // Unpack options
  newOptions.skip = len &gt; 3 ? args[2] : options.skip ? options.skip : 0;
  newOptions.limit = len &gt; 3 ? args[3] : options.limit ? options.limit : 0;
  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
  // // If we have overridden slaveOk otherwise use the default db setting
  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;

  // Add read preference if needed
  newOptions = getReadPreference(this, newOptions, this.s.db, this);
  // Set slave ok to true if read preference different from primary
  if(newOptions.readPreference != null
    && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {
    newOptions.slaveOk = true;
  }

  // Ensure the query is an object
  if(selector != null ...</pre></li>
<li>example usage<pre class="docApiCodePre">...

      col.insert([{i:1}, {i:2}], {w:1}, function(err, docs) {
        test.equal(null, err);

        col.ensureIndex({i:1}, function(err, r) {
          test.equal(null, err);

          col.<span class="docApiCodeKeywordSpan">find</span>({i:1}, {hint: "_id_"}).count(function(err, count) {
test.equal(null, err);
test.equal(1, count);

col.find({}, {hint: "_id_"}).count(function(err, count) {
  test.equal(null, err);
  test.equal(2, count);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findAndModify" id="element.mongodb.Collection.findAndModify">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findAndModify
<span class="docApiSignatureSpan">(query, sort, doc, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findAndModify = function (query, sort, doc, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};

  // Clone options
  var options = shallowClone(options);
  // Force read preference primary
  options.readPreference = ReadPreference.PRIMARY;

  // Execute using callback
  if(typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    options = options || {};

    findAndModify(self, query, sort, doc, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_find_and_modify_a_document', function(err, collection) {
        // Test return new document on change
        collection.insert({'a':1, 'b':2}, configuration.writeConcernMax(), function(err, doc) {
          // Let's modify the document in place
          collection.<span class="docApiCodeKeywordSpan">findAndModify</span>({'a':1}, [['a', 1]], {'$set':{'b':3}}, {'new':true}, function(err, updated_doc) {
test.equal(1, updated_doc.value.a);
test.equal(3, updated_doc.value.b);

// Test return old document on change
collection.insert({'a':2, 'b':2}, configuration.writeConcernMax(), function(err, doc) {
  // Let's modify the document in place
  collection.findAndModify({'a':2}, [['a', 1]], {'$set':{'b':3}}, configuration.writeConcernMax(), function(err, result, object) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findAndRemove" id="element.mongodb.Collection.findAndRemove">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findAndRemove
<span class="docApiSignatureSpan">(query, sort, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findAndRemove = function (query, sort, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return findAndRemove(self, query, sort, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    findAndRemove(self, query, sort, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
      var collection = db.collection('simple_find_and_modify_operations_2');
      // Insert some test documentations
      collection.insertMany([{a:1}, {b:1, d:1}, {c:1}], configuration.writeConcernMax(), function(err, result) {
        test.equal(null, err);

        // Simple findAndModify command returning the old document and
        // removing it at the same time
        collection.<span class="docApiCodeKeywordSpan">findAndRemove</span>({b:1}, [['b', 1]], function(err, doc) {
test.equal(null, err);
test.equal(1, doc.value.b);
test.equal(1, doc.value.d);

// Verify that the document is gone
collection.findOne({b:1}, function(err, item) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findOne" id="element.mongodb.Collection.findOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOne
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findOne = function () {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  var callback = args.pop();
  if(typeof callback != 'function') args.push(callback);

  // Execute using callback
  if(typeof callback == 'function') return findOne(self, args, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    findOne(self, args, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

      col.insert({a:1, b:1}, function(err, result) {
        test.equal(null, err);

        col.update({a:1}, {$bit: {b: {and: 0}}}, function(err, result) {
test.equal(null, err);

col.<span class="docApiCodeKeywordSpan">findOne</span>({a:1}, function(err, doc) {
  test.equal(null, err);
  test.equal(1, doc.a);
  test.equal(0, doc.b);

  db.close();
  test.done();
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findOneAndDelete" id="element.mongodb.Collection.findOneAndDelete">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndDelete
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findOneAndDelete = function (filter, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return findOneAndDelete(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    options = options || {};

    findOneAndDelete(self, filter, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN
      // Get the collection
      var col = db.collection('find_one_and_delete');
      col.insertMany([{a:1, b:1}], {w:1}, function(err, r) {
        test.equal(null, err);
        test.equal(1, r.result.n);

        col.<span class="docApiCodeKeywordSpan">findOneAndDelete</span>({a:1}
          , { projection: {b:1}, sort: {a:1} }
          , function(err, r) {
test.equal(null, err);
test.equal(1, r.lastErrorObject.n);
test.equal(1, r.value.b);

db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findOneAndReplace" id="element.mongodb.Collection.findOneAndReplace">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndReplace
<span class="docApiSignatureSpan">(filter, replacement, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findOneAndReplace = function (filter, replacement, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    options = options || {};

    findOneAndReplace(self, filter, replacement, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN
      // Get the collection
      var col = db.collection('find_one_and_replace');
      col.insertMany([{a:1, b:1}], {w:1}, function(err, r) {
test.equal(null, err);
test.equal(1, r.result.n);

col.<span class="docApiCodeKeywordSpan">findOneAndReplace</span>({a:1}
  , {c:1, b:1}
  , {
        projection: {b:1, c:1}
      , sort: {a:1}
      , returnOriginal: false
      , upsert: true
    }
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.findOneAndUpdate" id="element.mongodb.Collection.findOneAndUpdate">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>findOneAndUpdate
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">findOneAndUpdate = function (filter, update, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    options = options || {};

    findOneAndUpdate(self, filter, update, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN
      // Get the collection
      var col = db.collection('find_one_and_update');
      col.insertMany([{a:1, b:1}], {w:1}, function(err, r) {
test.equal(null, err);
test.equal(1, r.result.n);

col.<span class="docApiCodeKeywordSpan">findOneAndUpdate</span>({a:1}
  , {$set: {d:1}}
  , {
        projection: {b:1, d:1}
      , sort: {a:1}
      , returnOriginal: false
      , upsert: true
    }
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.geoHaystackSearch" id="element.mongodb.Collection.geoHaystackSearch">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>geoHaystackSearch
<span class="docApiSignatureSpan">(x, y, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">geoHaystackSearch = function (x, y, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    geoHaystackSearch(self, x, y, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // Add a location based index
  collection.ensureIndex({loc: "geoHaystack", type: 1}, {bucketSize: 1}, function(err, result) {

    // Save a new location tagged document
    collection.insertMany([{a:1, loc:[50, 30]}, {a:1, loc:[30, 50]}], configuration.writeConcernMax(), function(err, result) {

      // Use geoNear command to find document
      collection.<span class="docApiCodeKeywordSpan">geoHaystackSearch</span>(50, 50, {search:{a:1}, limit:1, maxDistance:100}, function(err, docs) {
        test.equal(1, docs.results.length);
        db.close();
        test.done();
      });
    });
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.geoNear" id="element.mongodb.Collection.geoNear">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>geoNear
<span class="docApiSignatureSpan">(x, y, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">geoNear = function (x, y, options, callback) {
  var self = this;
  var point = typeof(x) == 'object' && x
    , args = Array.prototype.slice.call(arguments, point?1:2);

  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return geoNear(self, x, y, point, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    geoNear(self, x, y, point, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
// Add a location based index
collection.ensureIndex({loc:"2d"}, function(err, result) {

  // Save a new location tagged document
  collection.insertMany([{a:1, loc:[50, 30]}, {a:1, loc:[30, 50]}], configuration.writeConcernMax(), function(err, result) {

    // Use geoNear command to find document
    collection.<span class="docApiCodeKeywordSpan">geoNear</span>(50, 50, {query:{a:1}, num:1}, function(err, docs) {
      test.equal(1, docs.results.length);

      db.close();
      test.done();
    });
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.group" id="element.mongodb.Collection.group">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>group
<span class="docApiSignatureSpan">(keys, condition, initial, reduce, finalize, command, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 3);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || {} : {};

  // Make sure we are backward compatible
  if(!(typeof finalize == 'function')) {
    command = finalize;
    finalize = null;
  }

  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys instanceof Code)) {
    keys = Object.keys(keys);
  }

  if(typeof reduce === 'function') {
    reduce = reduce.toString();
  }

  if(typeof finalize === 'function') {
    finalize = finalize.toString();
  }

  // Set up the command as default
  command = command == null ? true : command;

  // Execute using callback
  if(typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    group(self, keys, condition, initial, reduce, finalize, command, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  metadata: { requires: { topology: ['single', 'replicaset', 'sharded', 'ssl', 'heap', 'wiredtiger'] } },

  // The actual test we wish to run
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_group2', function(err, collection) {
        collection.<span class="docApiCodeKeywordSpan">group</span>([], {}, {"count":0}, "function (obj, prev) { prev.count++; }", true, function(err, results) {
test.deepEqual([], results);

// Trigger some inserts
collection.insert([{'a':2}, {'b':5, 'a':0}, {'a':1}, {'c':2, 'a':0}], configuration.writeConcernMax(), function(err, ids) {
  collection.group([], {}, {count: 0, running_average: 0}
    , function (doc, out) {
        out.count++;
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.indexExists" id="element.mongodb.Collection.indexExists">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexExists
<span class="docApiSignatureSpan">(indexes, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">indexExists = function (indexes, callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return indexExists(self, indexes, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    indexExists(self, indexes, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN
      // Create a test collection that we are getting the options back from
      var collection = db.collection('test_collection_index_exists', configuration.writeConcernMax());
      test.equal(null, err);
      // Create an index on the collection
      collection.createIndex('a', configuration.writeConcernMax(), function(err, indexName) {
        // Let's test to check if a single index exists
        collection.<span class="docApiCodeKeywordSpan">indexExists</span>("a_1", function(err, result) {
          test.equal(true, result);

          // Let's test to check if multiple indexes are available
          collection.indexExists(["a_1", "_id_"], function(err, result) {
test.equal(true, result);

// Check if a non existing index exists
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.indexInformation" id="element.mongodb.Collection.indexInformation">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexInformation
<span class="docApiSignatureSpan">(options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">indexInformation = function (options, callback) {
  var self = this;
  // Unpack calls
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return indexInformation(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    indexInformation(self, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        collection.ensureIndex({createdAt:1}, {expireAfterSeconds:1, w: 1}, function(err, result) {
          test.equal(null, err);

          // Insert a document with a date
          collection.insert({a:1, createdAt:new Date()}, configuration.writeConcernMax(), function(err, result) {
            test.equal(null, err);

            collection.<span class="docApiCodeKeywordSpan">indexInformation</span>({full:true}, function(err, indexes) {
test.equal(null, err);

for(var i = 0; i &lt; indexes.length; i++) {
  if(indexes[i].name == "createdAt_1") {
    test.equal(1, indexes[i].expireAfterSeconds);
    break;
  }
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.indexes" id="element.mongodb.Collection.indexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>indexes
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">indexes = function (callback) {
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return indexes(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    indexes(self, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

// Create a simple single field index
collection.ensureIndex({a:1}, configuration.writeConcernMax(), function(err, result) {
  test.equal(null, err);

  setTimeout(function() {
    // List all of the indexes on the collection
    collection.<span class="docApiCodeKeywordSpan">indexes</span>(function(err, indexes) {
      test.equal(3, indexes.length);

      db.close();
      test.done();
    });
  }, 1000);
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.initializeOrderedBulkOp" id="element.mongodb.Collection.initializeOrderedBulkOp">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>initializeOrderedBulkOp
<span class="docApiSignatureSpan">(options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">initializeOrderedBulkOp = function (options) {
  options = options || {};
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        db.admin().addUser('admin', 'admin', function(err, result) {
test.equal(null, err);

// Attempt to save a document
var col = db.collection('test');

// Initialize the Ordered Batch
var batch = col.<span class="docApiCodeKeywordSpan">initializeOrderedBulkOp</span>();

// Add some operations to be executed in order
batch.insert({a:1});
batch.find({a:1}).updateOne({$set: {b:1}});
batch.find({a:2}).upsert().updateOne({$set: {b:2}});
batch.insert({a:3});
batch.find({a:3}).remove({a:3});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.initializeUnorderedBulkOp" id="element.mongodb.Collection.initializeUnorderedBulkOp">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>initializeUnorderedBulkOp
<span class="docApiSignatureSpan">(options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">initializeUnorderedBulkOp = function (options) {
  options = options || {};
  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        db.admin().addUser('admin', 'admin', function(err, result) {
test.equal(null, err);

// Attempt to save a document
var col = db.collection('test');

// Initialize the Ordered Batch
var batch = col.<span class="docApiCodeKeywordSpan">initializeUnorderedBulkOp</span>();

// Add some operations to be executed in order
batch.insert({a:1});
batch.find({a:1}).updateOne({$set: {b:1}});
batch.find({a:2}).upsert().updateOne({$set: {b:2}});
batch.insert({a:3});
batch.find({a:3}).remove({a:3});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.insert" id="element.mongodb.Collection.insert">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insert
<span class="docApiSignatureSpan">(docs, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">insert = function (docs, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {ordered:false};
  docs = !Array.isArray(docs) ? [docs] : docs;

  if(options.keepGoing == true) {
    options.ordered = false;
  }

  return this.insertMany(docs, options, callback);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configure, test) {
    var db = configure.newDbInstance({w:1}, {poolSize:1});
    db.open(function(err, db) {
      // Create a collection
      var col = db.collection('shouldPerformSimpleGroupAggregation');
      col.remove({}, function() {
        // Insert a single document
        col.<span class="docApiCodeKeywordSpan">insert</span>([{a:1}, {a:1}, {a:1}], function(err, r) {
test.equal(null, err);
test.equal(3, r.result.n);

// Get first two documents that match the query
col.aggregate([
      {$match: {}}
    , {$group:
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.insertMany" id="element.mongodb.Collection.insertMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insertMany
<span class="docApiSignatureSpan">(docs, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">insertMany = function (docs, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {ordered:true};
  if(!Array.isArray(docs)) return callback(MongoError.create({message: 'docs parameter must be an array of documents', driver:true }));

  // Get the write concern options
  if(typeof options.checkKeys != 'boolean') {
    options.checkKeys = true;
  }

  // If keep going set unordered
  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Do we want to force the server to assign the _id key
  if(options.forceServerObjectId == null || options.forceServerObjectId == false) {
    // Add _id if not specified
    for(var i = 0; i &lt; docs.length; i++) {
      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
    }
  }

  // Generate the bulk write operations
  var operations = [{
    insertMany: docs
  }];

  // Execute using callback
  if(typeof callback == 'function') return bulkWrite(self, operations, options, function(err, r) {
    if(err) return callback(err, r);
    callback(null, mapInserManyResults(docs, r));
  });

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    bulkWrite(self, operations, options, function(err, r) {
      if(err) return reject(err);
      resolve(mapInserManyResults(docs, r));
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
      test.equal(null, err);

      var col = db.collection('shouldCorrectlyExecuteInsertOneWithW0');
      col.insertOne({a:1}, {w:0}, function(err,result) {
        test.equal(null, err);
        test.equal(1, result.result.ok);

        col.<span class="docApiCodeKeywordSpan">insertMany</span>([{a:1}], {w:0}, function(err, result) {
test.equal(null, err);
test.equal(1, result.result.ok);

col.updateOne({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.insertOne" id="element.mongodb.Collection.insertOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>insertOne
<span class="docApiSignatureSpan">(doc, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">insertOne = function (doc, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};
  if(Array.isArray(doc)) return callback(MongoError.create({message: 'doc parameter must be an object', driver:true }));

  // Execute using callback
  if(typeof callback == 'function') return insertOne(self, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    insertOne(self, doc, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1, auto_reconnect:false});
    // Establish connection to db
    db.open(function(err, db) {
      test.equal(null, err);

      var col = db.collection('shouldCorrectlyExecuteInsertOneWithW0');
      col.<span class="docApiCodeKeywordSpan">insertOne</span>({a:1}, {w:0}, function(err,result) {
test.equal(null, err);
test.equal(1, result.result.ok);

col.insertMany([{a:1}], {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.isCapped" id="element.mongodb.Collection.isCapped">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>isCapped
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">isCapped = function (callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return isCapped(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    isCapped(self, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
// BEGIN

  // Create a test collection that we are getting the options back from
  db.createCollection('test_collection_is_capped', {'capped':true, 'size':1024}, function(err, collection) {
    test.equal('test_collection_is_capped', collection.collectionName);

    // Let's fetch the collection options
    collection.<span class="docApiCodeKeywordSpan">isCapped</span>(function(err, capped) {
      test.equal(true, capped);

      db.close();
      test.done();
    });
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.listIndexes" id="element.mongodb.Collection.listIndexes">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>listIndexes
<span class="docApiSignatureSpan">(options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">listIndexes = function (options) {
  options = options || {};
  // Clone the options
  options = shallowClone(options);
  // Set the CommandCursor constructor
  options.cursorFactory = CommandCursor;
  // Set the promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // We have a list collections command
  if(this.s.db.serverConfig.capabilities().hasListIndexesCommand) {
    // Cursor options
    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
    // Build the command
    var command = { listIndexes: this.s.name, cursor: cursor };
    // Execute the cursor
    return this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
  }

  // Get the namespace
  var ns = f('%s.system.indexes', this.s.dbName);
  // Get the query
  return this.s.topology.cursor(ns, {find: ns, query: {ns: this.s.namespace}}, options);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
db.collection('testListIndexes').ensureIndex({a:1}, function(err, r) {
  test.equal(null, err);

  // Get the list of indexes
  db.collection('testListIndexes').<span class="docApiCodeKeywordSpan">listIndexes</span>().toArray(function(err, indexes) {
    test.equal(null, err);
    test.equal(2, indexes.length);

    db.close();
    test.done();
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.mapReduce" id="element.mongodb.Collection.mapReduce">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>mapReduce
<span class="docApiSignatureSpan">(map, reduce, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">mapReduce = function (map, reduce, options, callback) {
  var self = this;
  if('function' === typeof options) callback = options, options = {};
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
  if(null == options.out) {
    throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
  }

  if('function' === typeof map) {
    map = map.toString();
  }

  if('function' === typeof reduce) {
    reduce = reduce.toString();
  }

  if('function' === typeof options.finalize) {
    options.finalize = options.finalize.toString();
  }

  // Execute using callback
  if(typeof callback == 'function') return mapReduce(self, map, reduce, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    mapReduce(self, map, reduce, options, function(err, r, r1) {
      if(err) return reject(err);
      if(r instanceof Collection) return resolve(r);
      resolve({results: r, stats: r1});
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    db.open(function(err, db) {
      db.createCollection('test_map_reduce', function(err, collection) {
        collection.insert([{'user_id':1}, {'user_id':2}], configuration.writeConcernMax(), function(err, r) {
          // String functions
          var map = "function() { emit(this.user_id, 1); }";
          var reduce = "function(k,vals) { return 1; }";

          collection.<span class="docApiCodeKeywordSpan">mapReduce</span>(map, reduce, {out: {replace : 'tempCollection'}}, function(err, collection) {
collection.findOne({'_id':1}, function(err, result) {
  test.equal(1, result.value);
});

collection.findOne({'_id':2}, function(err, result) {
  test.equal(1, result.value);
  db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.options" id="element.mongodb.Collection.options">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>options
<span class="docApiSignatureSpan">(callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">options = function (callback) {
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return options(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    options(self, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN

// Create a test collection that we are getting the options back from
db.createCollection('test_collection_options', {'capped':true, 'size':1024}, function(err, collection) {
  test.equal('test_collection_options', collection.collectionName);

  // Let's fetch the collection options
  collection.<span class="docApiCodeKeywordSpan">options</span>(function(err, options) {
    test.equal(true, options.capped);
    test.ok(options.size &gt;= 1024);

    db.close();
    test.done();
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.parallelCollectionScan" id="element.mongodb.Collection.parallelCollectionScan">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>parallelCollectionScan
<span class="docApiSignatureSpan">(options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">parallelCollectionScan = function (options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {numCursors: 1};
  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // Add a promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Execute using callback
  if(typeof callback == 'function') return parallelCollectionScan(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    parallelCollectionScan(self, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
      var collection = db.collection('parallelCollectionScan_2');
      // Insert 2000 documents in a batch
      collection.insert(docs, function(err, result) {
        var results = [];
        var numCursors = 3;

        // Execute parallelCollectionScan command
        collection.<span class="docApiCodeKeywordSpan">parallelCollectionScan</span>({numCursors:numCursors}, function(err, cursors) {
test.equal(null, err);
test.ok(cursors != null);
test.ok(cursors.length &gt; 0);
test.ok(cursors.length &lt;= numCursors);
var left = cursors.length;

for(var i = 0; i &lt; cursors.length; i++) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.reIndex" id="element.mongodb.Collection.reIndex">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>reIndex
<span class="docApiSignatureSpan">(options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">reIndex = function (options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return reIndex(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    reIndex(self, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
          test.equal(null, err);

          // Create an index on the a field
          collection.ensureIndex({a:1, b:1}
            , {unique:true, background:true, w:1}, function(err, indexName) {

            // Force a reindex of the collection
            collection.<span class="docApiCodeKeywordSpan">reIndex</span>('create_and_drop_all_indexes', function(err, result) {
test.equal(null, err);
test.equal(true, result);

// Verify that the index is gone
collection.indexInformation(function(err, indexInformation) {
  test.deepEqual([ [ '_id', 1 ] ], indexInformation._id_);
  test.deepEqual([ [ 'a', 1 ], [ 'b', 1 ] ], indexInformation.a_1_b_1);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.remove" id="element.mongodb.Collection.remove">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>remove
<span class="docApiSignatureSpan">(selector, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">remove = function (selector, options, callback) {
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return removeDocuments(self, selector, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    removeDocuments(self, selector, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  
  // The actual test we wish to run
  test: function(configure, test) {
    var db = configure.newDbInstance({w:1}, {poolSize:1});
    db.open(function(err, db) {
      // Create a collection
      var col = db.collection('shouldPerformSimpleGroupAggregation');
      col.<span class="docApiCodeKeywordSpan">remove</span>({}, function() {
        // Insert a single document
        col.insert([{a:1}, {a:1}, {a:1}], function(err, r) {
test.equal(null, err);
test.equal(3, r.result.n);

// Get first two documents that match the query
col.aggregate([
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.removeMany" id="element.mongodb.Collection.removeMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>removeMany
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">removeMany = function (filter, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  var options = shallowClone(options);

  // Execute using callback
  if(typeof callback == 'function') return deleteMany(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    deleteMany(self, filter, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
      // Get the collection
      var col = db.collection('remove_many');
      col.insertMany([{a:1}, {a:1}], function(err, r) {
test.equal(null, err);
test.equal(2, r.insertedCount);

// Update all documents
col.<span class="docApiCodeKeywordSpan">removeMany</span>({a:1}, function(err, r) {
  test.equal(null, err);
  test.equal(2, r.deletedCount);

  // Finish up test
  db.close();
  test.done();
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.removeOne" id="element.mongodb.Collection.removeOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>removeOne
<span class="docApiSignatureSpan">(filter, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">removeOne = function (filter, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  var options = shallowClone(options);

  // Execute using callback
  if(typeof callback == 'function') return deleteOne(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    deleteOne(self, filter, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    // BEGIN
// Get the collection
var col = db.collection('remove_one');
col.insertMany([{a:1}, {a:1}], function(err, r) {
  test.equal(null, err);
  test.equal(2, r.insertedCount);

  col.<span class="docApiCodeKeywordSpan">removeOne</span>({a:1}, function(err, r) {
    test.equal(null, err);
    test.equal(1, r.deletedCount);
    // Finish up test
    db.close();
    test.done();
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.rename" id="element.mongodb.Collection.rename">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>rename
<span class="docApiSignatureSpan">(newName, opt, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">rename = function (newName, opt, callback) {
  var self = this;
  if(typeof opt == 'function') callback = opt, opt = {};
  opt = opt || {};

  // Execute using callback
  if(typeof callback == 'function') return rename(self, newName, opt, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    rename(self, newName, opt, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  })

  d.run(function() {
    db.open(function(err, db) {
      // Execute code
      db.createCollection('shouldCorrectlyHandleThrownErrorInRename', function(err, r) {
        db.collection('shouldCorrectlyHandleThrownError', function(err, collection) {
          collection.<span class="docApiCodeKeywordSpan">rename</span>("shouldCorrectlyHandleThrownErrorInRename2", function(err, result) {
            debug(someUndefinedVariable);
          })
        });
      });
    });
  })
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.replaceOne" id="element.mongodb.Collection.replaceOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>replaceOne
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">replaceOne = function (filter, update, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = shallowClone(options)

  // Execute using callback
  if(typeof callback == 'function') return replaceOne(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    replaceOne(self, filter, update, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  });
}

//
// Replace one method
// -------------------------------------------------
var replaceOne = function() {
  db.collection('t3_3').<span class="docApiCodeKeywordSpan">replaceOne</span>({ a: 1 }
    , { a : 2 }
    , { upsert: true }, function(err, r) {
    test.equal(null, err);
    test.equal(1, r.result.n);
    test.equal(1, r.matchedCount);
    test.equal(1, r.ops.length);
    test.ok(r.upsertedId != null);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.save" id="element.mongodb.Collection.save">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>save
<span class="docApiSignatureSpan">(doc, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">save = function (doc, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = options || {};

  // Execute using callback
  if(typeof callback == 'function') return save(self, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    save(self, doc, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var ObjectID = configuration.require.ObjectID;

    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_save', function(err, collection) {
        var doc = {'hello':'world'};
        collection.<span class="docApiCodeKeywordSpan">save</span>(doc, configuration.writeConcernMax(), function(err, r) {
          test.ok(r.ops[0]._id != null);

          collection.count(function(err, count) {
test.equal(1, count);

collection.save(r.ops[0], configuration.writeConcernMax(), function(err, doc2) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.stats" id="element.mongodb.Collection.stats">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>stats
<span class="docApiSignatureSpan">(options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">stats = function (options, callback) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || {} : {};

  // Execute using callback
  if(typeof callback == 'function') return stats(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    stats(self, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // Crete the collection for the distinct example
  var collection = db.collection('collection_stats_test');

  // Insert some documents
  collection.insertMany([{a:1}, {hello:'world'}], configuration.writeConcernMax(), function(err, result) {

    // Retrieve the statistics for the collection
    collection.<span class="docApiCodeKeywordSpan">stats</span>(function(err, stats) {
      test.equal(2, stats.count);

      db.close();
      test.done();
    });
  });
});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.update" id="element.mongodb.Collection.update">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>update
<span class="docApiSignatureSpan">(selector, document, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">update = function (selector, document, options, callback) {
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return updateDocuments(self, selector, document, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    updateDocuments(self, selector, document, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {native_parser:false})
    db.open(function(err, db) {
      var col = db.collection('shouldCorrectlyApplyBitOperator');

      col.insert({a:1, b:1}, function(err, result) {
        test.equal(null, err);

        col.<span class="docApiCodeKeywordSpan">update</span>({a:1}, {$bit: {b: {and: 0}}}, function(err, result) {
test.equal(null, err);

col.findOne({a:1}, function(err, doc) {
  test.equal(null, err);
  test.equal(1, doc.a);
  test.equal(0, doc.b);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.updateMany" id="element.mongodb.Collection.updateMany">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>updateMany
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">updateMany = function (filter, update, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = shallowClone(options)

  // Execute using callback
  if(typeof callback == 'function') return updateMany(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    updateMany(self, filter, update, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
          test.equal(null, err);
          test.equal(1, result.result.ok);

          col.updateOne({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
            test.equal(null, err);
            test.equal(1, result.result.ok);

            col.<span class="docApiCodeKeywordSpan">updateMany</span>({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
test.equal(null, err);
test.equal(1, result.result.ok);

col.deleteOne({a:1}, {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.Collection.updateOne" id="element.mongodb.Collection.updateOne">
function <span class="docApiSignatureSpan">mongodb.Collection.</span>updateOne
<span class="docApiSignatureSpan">(filter, update, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">updateOne = function (filter, update, options, callback) {
  var self = this;
  if(typeof options == 'function') callback = options, options = {};
  options = shallowClone(options)

  // Execute using callback
  if(typeof callback == 'function') return updateOne(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) {
    updateOne(self, filter, update, options, function(err, r) {
      if(err) return reject(err);
      resolve(r);
    });
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        test.equal(null, err);
        test.equal(1, result.result.ok);

        col.insertMany([{a:1}], {w:0}, function(err, result) {
          test.equal(null, err);
          test.equal(1, result.result.ok);

          col.<span class="docApiCodeKeywordSpan">updateOne</span>({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
test.equal(null, err);
test.equal(1, result.result.ok);

col.updateMany({a:1}, {$set: {b:1}}, {w:0}, function(err, result) {
  test.equal(null, err);
  test.equal(1, result.result.ok);
...</pre></li>
</ul>

</div>

<div class="docApiSectionDiv">
<h1><a href="#module.mongodb.MongoClient" id="module.mongodb.MongoClient">module mongodb.MongoClient</a></h1>

<h2><a href="#element.mongodb.MongoClient.connect" id="element.mongodb.MongoClient.connect">
function <span class="docApiSignatureSpan">mongodb.MongoClient.</span>connect
<span class="docApiSignatureSpan">(url, options, callback)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">connect = function (url, options, callback) {
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
  options = args.length ? args.shift() : null;
  options = options || {};

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) {
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  }

  // Return a promise
  if(typeof callback != 'function') {
    return new promiseLibrary(function(resolve, reject) {
      connect(url, options, function(err, db) {
        if(err) return reject(err);
        resolve(db);
      });
    });
  }

  // Fallback to callback based connect
  connect(url, options, callback);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
modeNext = error
    ? Infinity
    : modeNext + 1;
console.log('step ' + modeNext);
switch (modeNext) {
case 1:
    console.log('connecting to mongodb server');
    local.mongodb.MongoClient.<span class="docApiCodeKeywordSpan">connect</span>(
        'mongodb://localhost:27017/test',
        onNext
    );
    break;
case 2:
    local.db = data;
    console.log('connected to mongodb server');
...</pre></li>
</ul>

</div>

<div class="docApiSectionDiv">
<h1><a href="#module.mongodb.bson" id="module.mongodb.bson">module mongodb.bson</a></h1>

<h2><a href="#element.mongodb.bson.BSON" id="element.mongodb.bson.BSON">
function <span class="docApiSignatureSpan">mongodb.bson.</span>BSON
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function BSON() {}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        collection.insert([{a:1}, {b:2000}, {c:2.3}], {w:1}, function(err, result) {
          // You have to pass at least query + fields before passing options
          collection.find({}, null, {raw:true, batchSize: 2}).toArray(function(err, items) {
var objects = [];

for(var i = 0; i &lt; items.length; i++) {
  test.ok(Buffer.isBuffer(items[i]));
  objects.push(new <span class="docApiCodeKeywordSpan">BSON</span>().deserialize(items[i]));
}

test.equal(1, objects[0].a);
test.equal(2000, objects[1].b);
test.equal(2.3, objects[2].c);

// Execute findOne
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Binary" id="element.mongodb.bson.Binary">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Binary
<span class="docApiSignatureSpan">(buffer, subType)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);
  
  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {    
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null && !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;      
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);      
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

  // The actual test we wish to run
  test: function(configuration, test) {
var Binary = configuration.require.Binary;
var docs = []

for(var i = 0; i &lt; 10000; i++) {
  docs.push({'a':i, bin: new <span class="docApiCodeKeywordSpan">Binary</span>(new Buffer(256))})
}

var db = configuration.newDbInstance({w:0}, {poolSize:1});
var j = 0;

var allDocs = [];
while(docs.length &gt; 0) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Code" id="element.mongodb.bson.Code">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Code
<span class="docApiSignatureSpan">(code, scope)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope == null ? {} : scope;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    db.open(function(err, db) {
      db.createCollection('test_where', function(err, collection) {
        collection.insert([{'a':1}, {'a':2}, {'a':3}], configuration.writeConcernMax(), function(err, ids) {
          collection.count(function(err, count) {
            test.equal(3, count);

            // Let's test usage of the $where statement
            collection.find({'$where':new <span class="docApiCodeKeywordSpan">Code</span>('this.a &gt; 2')}).count(function(err, count) {
              test.equal(1, count);

              collection.find({'$where':new Code('this.a &gt; i', {i:1})}).count(function(err, count) {
test.equal(2, count);

// Let's close the db
db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.DBRef" id="element.mongodb.bson.DBRef">
function <span class="docApiSignatureSpan">mongodb.bson.</span>DBRef
<span class="docApiSignatureSpan">(namespace, oid, db)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
  
  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
        db.createCollection('test_resave_dbref', function(err, collection) {
          test.equal(null, err);

          collection.insert({'name': 'parent'}, {safe : true}, function(err, r) {
            test.equal(null, err);
            test.ok(r.ops.length == 1 && r.ops[0]._id != null);
            var parent = r.ops[0];
            var child = {'name' : 'child', 'parent' : new <span class="docApiCodeKeywordSpan">DBRef</span>("test_resave_dbref",  parent._id)};

            collection.insert(child, {safe : true}, function(err, objs) {
test.equal(null, err);

collection.findOne({'name' : 'child'}, function(err, child) { //Child deserialized
  test.ok(child != null);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Double" id="element.mongodb.bson.Double">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Double
<span class="docApiSignatureSpan">(value)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Double(value) {
  if(!(this instanceof Double)) return new Double(value);
  
  this._bsontype = 'Double';
  this.value = value;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new Symbol("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new <span class="docApiCodeKeywordSpan">Double</span>(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new MinKey()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}

collection.insert(document, configuration.writeConcernMax(), function(err, result) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Long" id="element.mongodb.bson.Long">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Long
<span class="docApiSignatureSpan">(low, high)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);
  
  this._bsontype = 'Long';
<span class="docApiCodeCommentSpan">  /**
   * @type {number}
   * @api private
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

// Unpack the cursor
var lowBits = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;
var highBits = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;
// Create long object
this.cursorId = new <span class="docApiCodeKeywordSpan">Long</span>(lowBits, highBits);

// Unpack the starting from
this.startingFrom = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
this.index = this.index + 4;

// Unpack the number of objects returned
this.numberReturned = data[this.index] | data[this.index + 1] &lt;&lt; 8 | data[this.index + 2] &lt;&lt; 16 | data[this.index + 3] &lt;&lt; 24;
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.MaxKey" id="element.mongodb.bson.MaxKey">
function <span class="docApiSignatureSpan">mongodb.bson.</span>MaxKey
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();
  
  this._bsontype = 'MaxKey';  
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

      var document = {
  "symbol": new Symbol("abcdefghijkl")
, "objid": new ObjectID("abcdefghijkl")
, "double": new Double(1)
, "binary": new Binary(new Buffer("hello world"))
, "minkey": new MinKey()
, "maxkey": new <span class="docApiCodeKeywordSpan">MaxKey</span>()
, "code": new Code("function () {}", {a: 55})
      }

      collection.insert(document, configuration.writeConcernMax(), function(err, result) {
test.equal(null, err);

collection.findOne({"symbol": new Symbol("abcdefghijkl")}, function(err, doc) {
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.MinKey" id="element.mongodb.bson.MinKey">
function <span class="docApiSignatureSpan">mongodb.bson.</span>MinKey
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();
  
  this._bsontype = 'MinKey';
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new Symbol("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new Double(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new <span class="docApiCodeKeywordSpan">MinKey</span>()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}

collection.insert(document, configuration.writeConcernMax(), function(err, result) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.ObjectID" id="element.mongodb.bson.ObjectID">
function <span class="docApiSignatureSpan">mongodb.bson.</span>ObjectID
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function ObjectID(id, _hex) {
  if(!(this instanceof ObjectID)) return new ObjectID(id, _hex);

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24))
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  // Generate id based on the input
  if(id == null || typeof id == 'number') {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null && id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(checkForHexRegExp.test(id)) {
    return ObjectID.createFromHexString(id);
  } else {
    throw new Error("Value passed in is not a valid 24 character hex string");
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // The actual test we wish to run
  test: function(configuration, test) {
    var ObjectID = configuration.require.ObjectID;

    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
      db.createCollection('test_should_correctly_do_update_with_no_docs', function(err, collection) {
        var id = new <span class="docApiCodeKeywordSpan">ObjectID</span>(null)
        var doc = {_id:id, a:1};

        collection.update({"_id":id}, doc, configuration.writeConcernMax(), function(err, r) {
test.equal(null, err);
test.equal(0, r.result.n);

db.close();
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.ObjectId" id="element.mongodb.bson.ObjectId">
function <span class="docApiSignatureSpan">mongodb.bson.</span>ObjectId
<span class="docApiSignatureSpan">(id, _hex)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function ObjectID(id, _hex) {
  if(!(this instanceof ObjectID)) return new ObjectID(id, _hex);

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24))
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  // Generate id based on the input
  if(id == null || typeof id == 'number') {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null && id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(checkForHexRegExp.test(id)) {
    return ObjectID.createFromHexString(id);
  } else {
    throw new Error("Value passed in is not a valid 24 character hex string");
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
<li>example usage<pre class="docApiCodePre">n/a</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Symbol" id="element.mongodb.bson.Symbol">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Symbol
<span class="docApiSignatureSpan">(value)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
, Code = configuration.require.Code;

    var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
    db.open(function(err, db) {
var collection = db.collection('bson_types_insert');

var document = {
    "symbol": new <span class="docApiCodeKeywordSpan">Symbol</span>("abcdefghijkl")
  , "objid": new ObjectID("abcdefghijkl")
  , "double": new Double(1)
  , "binary": new Binary(new Buffer("hello world"))
  , "minkey": new MinKey()
  , "maxkey": new MaxKey()
  , "code": new Code("function () {}", {a: 55})
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.Timestamp" id="element.mongodb.bson.Timestamp">
function <span class="docApiSignatureSpan">mongodb.bson.</span>Timestamp
<span class="docApiSignatureSpan">(low, high)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
<span class="docApiCodeCommentSpan">  /**
   * @type {number}
   * @api private
   */
</span>  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
var ObjectID = configuration.require.ObjectID
  , Timestamp = configuration.require.Timestamp;

var doc = {
 "_id" : new ObjectID("4e886e687ff7ef5e00000162"),
 "str" : "foreign",
 "type" : 2,
 "timestamp" : new <span class="docApiCodeKeywordSpan">Timestamp</span>(10000),
 "links" : [
   "http://www.reddit.com/r/worldnews/comments/kybm0/uk_home_secretary_calls_for_the_scrapping_of_the/"
 ],
 "timestamp2" : new Timestamp(33333),
}

var db = configuration.newDbInstance(configuration.writeConcernMax(), {poolSize:1});
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.native" id="element.mongodb.bson.native">
function <span class="docApiSignatureSpan">mongodb.bson.</span>native
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">native = function () {     return module.exports; }</pre></li>
<li>example usage<pre class="docApiCodePre">...

var inherits = require('util').inherits
, f = require('util').format
, b = require('bson')
, bindToCurrentDomain = require('../connection/utils').bindToCurrentDomain
, EventEmitter = require('events').EventEmitter
, BasicCursor = require('../cursor')
, BSON = require('bson').<span class="docApiCodeKeywordSpan">native</span>().BSON
, BasicCursor = require('../cursor')
, Server = require('./server')
, Logger = require('../connection/logger')
, ReadPreference = require('./read_preference')
, Session = require('./session')
, MongoError = require('../error');
...</pre></li>
</ul>

<h2><a href="#element.mongodb.bson.pure" id="element.mongodb.bson.pure">
function <span class="docApiSignatureSpan">mongodb.bson.</span>pure
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">pure = function () {     return module.exports; }</pre></li>
<li>example usage<pre class="docApiCodePre">...
 */
exports.shouldCorrectlySaveDocumentsAndReturnAsRaw = {
  metadata: { requires: { topology: ['single', 'replicaset', 'sharded', 'ssl', 'heap', 'wiredtiger'] } },

  // The actual test we wish to run
  test: function(configuration, test) {
var Buffer = require('buffer').Buffer
  , BSON = require('mongodb-core').BSON.<span class="docApiCodeKeywordSpan">pure</span>().BSON;
  // console.dir(BSON)

var db = configuration.newDbInstance({w:1}, {poolSize:1});
db.open(function(err, db) {
  db.createCollection('shouldCorrectlySaveDocumentsAndReturnAsRaw', function(err, collection) {
    // Insert some documents
    collection.insert([{a:1}, {b:2000}, {c:2.3}], {w:1}, function(err, result) {
...</pre></li>
</ul>

</div>

<div class="docApiSectionDiv">
<h1><a href="#module.mongodb.core" id="module.mongodb.core">module mongodb.core</a></h1>

<h2><a href="#element.mongodb.core.Cursor" id="element.mongodb.core.Cursor">
function <span class="docApiSignatureSpan">mongodb.core.</span>Cursor
<span class="docApiSignatureSpan">(bson, ns, cmd, options, topology, topologyOptions)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {
  options = options || {};
  // Cursor reference
  var self = this;
  // Initial query
  var query = null;

  // Cursor connection
  this.connection = null;
  // Cursor server
  this.server = null;

  // Do we have a not connected handler
  this.disconnectHandler = options.disconnectHandler;

  // Set local values
  this.bson = bson;
  this.ns = ns;
  this.cmd = cmd;
  this.options = options;
  this.topology = topology;

  // All internal state
  this.cursorState = {
      cursorId: null
    , cmd: cmd
    , documents: options.documents || []
    , cursorIndex: 0
    , dead: false
    , killed: false
    , init: false
    , notified: false
    , limit: options.limit || cmd.limit || 0
    , skip: options.skip || cmd.skip || 0
    , batchSize: options.batchSize || cmd.batchSize || 1000
    , currentLimit: 0
    // Result field name if not a cursor (contains the array of results)
    , transforms: options.transforms
  }

  // Callback controller
  this.callbacks = null;

  // Logger
  this.logger = Logger('Cursor', options);

  //
  // Did we pass in a cursor id
  if(typeof cmd == 'number') {
    this.cursorState.cursorId = Long.fromNumber(cmd);
  } else if(cmd instanceof Long) {
    this.cursorState.cursorId = cmd;
  }
}</pre></li>
<li>example usage<pre class="docApiCodePre">n/a</pre></li>
</ul>

<h2><a href="#element.mongodb.core.GSSAPI" id="element.mongodb.core.GSSAPI">
function <span class="docApiSignatureSpan">mongodb.core.</span>GSSAPI
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">GSSAPI = function () {
  this.authStore = [];
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
  getSingleProperty(this, 'id', s.id);

  // Add auth providers
  this.addAuthProvider('mongocr', new MongoCR());
  this.addAuthProvider('x509', new X509());
  this.addAuthProvider('plain', new Plain());
  this.addAuthProvider('gssapi', new <span class="docApiCodeKeywordSpan">GSSAPI</span>());
  this.addAuthProvider('sspi', new SSPI());
  this.addAuthProvider('scram-sha-1', new ScramSHA1());
}

inherits(Server, EventEmitter);

/**
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.Logger" id="element.mongodb.core.Logger">
function <span class="docApiSignatureSpan">mongodb.core.</span>Logger
<span class="docApiSignatureSpan">(className, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Logger = function (className, options) {
  if(!(this instanceof Logger)) return new Logger(className, options);
  options = options || {};

  // Current reference
  var self = this;
  this.className = className;

  // Current logger
  if(currentLogger == null && options.logger) {
    currentLogger = options.logger;
  } else if(currentLogger == null) {
    currentLogger = console.log;
  }

  // Set level of logging, default is error
  if(level == null) {
    level = options.loggerLevel || 'error';
  }

  // Add all class names
  if(filteredClasses[this.className] == null) classFilters[this.className] =  true;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
// Children db's
, children: []
// Topology
, topology: topology
// Options
, options: options
// Logger instance
, logger: <span class="docApiCodeKeywordSpan">Logger</span>('Db', options)
// Get the bson parser
, bson: topology ? topology.bson : null
// Authsource if any
, authSource: options.authSource
// Unpack read preference
, readPreference: options.readPreference
// Set buffermaxEntries
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.MongoCR" id="element.mongodb.core.MongoCR">
function <span class="docApiSignatureSpan">mongodb.core.</span>MongoCR
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">MongoCR = function () {
  this.authStore = [];
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
finalOptions.disconnectHandler = store;

// Create the Mongos
var mongos = new CMongos(seedlist, finalOptions)
// Server capabilities
var sCapabilities = null;
// Add auth prbufferMaxEntriesoviders
mongos.addAuthProvider('mongocr', new <span class="docApiCodeKeywordSpan">MongoCR</span>());

// Internal state
this.s = {
  // Create the Mongos
    mongos: mongos
  // Server capabilities
  , sCapabilities: sCapabilities
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.MongoError" id="element.mongodb.core.MongoError">
function <span class="docApiSignatureSpan">mongodb.core.</span>MongoError
<span class="docApiSignatureSpan">(message)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">function MongoError(message) {
  this.name = 'MongoError';
  this.message = message;
  Error.captureStackTrace(this, MongoError);
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
/**
* Set the current logger function
* @method
* @param {function} logger Logger function.
* @return {null}
*/
Logger.setCurrentLogger = function(logger) {
 if(typeof logger != 'function') throw new <span class="docApiCodeKeywordSpan">MongoError</span>("current logger must be a function");
 currentLogger = logger;
}

/**
* Set what classes to log.
* @method
* @param {string} type The type of filter (currently only class)
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.Mongos" id="element.mongodb.core.Mongos">
function <span class="docApiSignatureSpan">mongodb.core.</span>Mongos
<span class="docApiSignatureSpan">(seedlist, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Mongos = function (seedlist, options) {  
  var self = this;
  options = options || {};
  
  // Add event listener
  EventEmitter.call(this);

  // Validate seedlist
  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
  // Validate list
  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
  // Validate entries
  seedlist.forEach(function(e) {
    if(typeof e.host != 'string' || typeof e.port != 'number') 
      throw new MongoError("seedlist entry must contain a host and port");
  });

  // BSON Parser, ensure we have a single instance
  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;
  // Pick the right bson parser
  var bson = options.bson ? options.bson : bsonInstance;
  // Add bson parser to options
  options.bson = bson;

  // The Mongos state
  this.s = {
    // Seed list for sharding passed in
      seedlist: seedlist
    // Passed in options
    , options: options
    // Logger
    , logger: Logger('Mongos', options)
    // Reconnect tries
    , reconnectTries: options.reconnectTries || 30
    // Ha interval
    , haInterval: options.haInterval || 5000
    // Have omitted fullsetup
    , fullsetup: false
    // Cursor factory
    , Cursor: options.cursorFactory || BasicCursor
    // Current credentials used for auth
    , credentials: []
    // BSON Parser
    , bsonInstance: bsonInstance
    , bson: bson
    // Default state
    , state: DISCONNECTED
    // Swallow or emit errors
    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
    // Contains any alternate strategies for picking
    , readPreferenceStrategies: {}
    // Auth providers
    , authProviders: {}
    // Unique instance id
    , id: mongosId++
    // Authentication in progress
    , authInProgress: false
    // Servers added while auth in progress
    , authInProgressServers: []
    // Current retries left
    , retriesLeft: options.reconnectTries || 30
    // Do we have a not connected handler
    , disconnectHandler: options.disconnectHandler
  }

  // Set up the connection timeout for the options
  options.connectionTimeout = options.connectionTimeout || 1000;

  // Create a new state for the mongos
  this.s.mongosState = new State(this.s.readPreferenceStrategies);

  // BSON property (find a server and pass it along)
  Object.defineProperty(this, 'bson', {
    enumerable: true, get: function() { 
      var servers = self.s.mongosState.getAll();
      return servers.length &gt; 0 ? servers[0].bson : null; 
    }
  });

  Object.defineProperty(this, 'id', {
    enumerable:true, get: function() { return self.s.id; }
  });

  Object.defineProperty(this, 'type', {
    enumerable:true, get: function() { return 'mongos'; }
  });

  Object.defineProperty(this, 'haInterval', {
    enumerable:true, get: function() { return self.s.haInterval; }
  });

  Object.defineProperty(this, 'state', {
    enumerable:true, get: function() { return self.s.mongosState; }
  });
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  test: function(configuration, test) {
    var MongoClient = configuration.require.MongoClient
, Db = configuration.require.Db
, Server = configuration.require.Server
, Mongos = configuration.require.Mongos;

    setUpSharded(configuration, function(err) {
var mongos = new <span class="docApiCodeKeywordSpan">Mongos</span>([
    new Server( 'localhost', shardedManager.mongosStartPort),
  ], {poolSize: 1});

var db = new Db('node-native-test', mongos, {w:1});
db.open(function(err, p_db) {
  test.equal(null, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.Plain" id="element.mongodb.core.Plain">
function <span class="docApiSignatureSpan">mongodb.core.</span>Plain
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Plain = function () {
  this.authStore = [];
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  getProperty(this, 'bson', 'bson', s.options, {});
  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
  getSingleProperty(this, 'id', s.id);

  // Add auth providers
  this.addAuthProvider('mongocr', new MongoCR());
  this.addAuthProvider('x509', new X509());
  this.addAuthProvider('plain', new <span class="docApiCodeKeywordSpan">Plain</span>());
  this.addAuthProvider('gssapi', new GSSAPI());
  this.addAuthProvider('sspi', new SSPI());
  this.addAuthProvider('scram-sha-1', new ScramSHA1());
}

inherits(Server, EventEmitter);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.Query" id="element.mongodb.core.Query">
function <span class="docApiSignatureSpan">mongodb.core.</span>Query
<span class="docApiSignatureSpan">(bson, ns, query, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Query = function (bson, ns, query, options) {
  var self = this;
  // Basic options needed to be passed in
  if(ns == null) throw new Error("ns must be specified for query");
  if(query == null) throw new Error("query must be specified for query");

  // Validate that we are not passing 0x00 in the colletion name
  if(!!~ns.indexOf("\x00")) {
    throw new Error("namespace cannot contain a null character");
  }

  // Basic options
  this.bson = bson;
  this.ns = ns;
  this.query = query;

  // Ensure empty options
  this.options = options || {};

  // Additional options
  this.numberToSkip = options.numberToSkip || 0;
  this.numberToReturn = options.numberToReturn || 0;
  this.returnFieldSelector = options.returnFieldSelector || null;
  this.requestId = _requestId++;

  // Serialization option
  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
  this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
  this.batchSize = self.numberToReturn;

  // Flags
  this.tailable = false;
  this.slaveOk = false;
  this.oplogReply = false;
  this.noCursorTimeout = false;
  this.awaitData = false;
  this.exhaust = false;
  this.partial = false;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

// Merge in any options
if(opts.skip) command.skip = opts.skip;
if(opts.limit) command.limit = opts.limit;
if(self.s.options.hint) command.hint = self.s.options.hint;

// Build Query object
var query = new <span class="docApiCodeKeywordSpan">Query</span>(self.s.bson, f("%s.$cmd", self.s.ns.substr(0, delimiter)), command, {
    numberToSkip: 0, numberToReturn: -1
  , checkKeys: false
});

// Set up callback
callbacks.register(query.requestId, function(err, result) {
  if(err) return handleCallback(callback, err);
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.ReadPreference" id="element.mongodb.core.ReadPreference">
function <span class="docApiSignatureSpan">mongodb.core.</span>ReadPreference
<span class="docApiSignatureSpan">(preference, tags, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ReadPreference = function (preference, tags, options) {
  this.preference = preference;
  this.tags = tags;
  this.options = options;
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
}

if(joined &gt;= Object.keys(left).length) {
  db.collection('replset_insert0').insert({a:1}, function(err, result) {
    test.equal(null, err);

    db.command({ismaster:true}
      , {readPreference: new <span class="docApiCodeKeywordSpan">ReadPreference</span>('secondary')}
      , function(err, result) {
        test.equal(null, err);
        db.close();
        restartAndDone(configuration, test);
      });
  });
}
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.ReplSet" id="element.mongodb.core.ReplSet">
function <span class="docApiSignatureSpan">mongodb.core.</span>ReplSet
<span class="docApiSignatureSpan">(seedlist, options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ReplSet = function (seedlist, options) {
  var self = this;
  options = options || {};

  // Validate seedlist
  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
  // Validate list
  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
  // Validate entries
  seedlist.forEach(function(e) {
    if(typeof e.host != 'string' || typeof e.port != 'number')
      throw new MongoError("seedlist entry must contain a host and port");
  });

  // Add event listener
  EventEmitter.call(this);

  // Set the bson instance
  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;

  // Internal state hash for the object
  this.s = {
      options: options
    // Logger instance
    , logger: Logger('ReplSet', options)
    // Uniquely identify the replicaset instance
    , id: replSetId++
    // Index
    , index: 0
    // Ha Index
    , haId: 0
    // Current credentials used for auth
    , credentials: []
    // Factory overrides
    , Cursor: options.cursorFactory || BasicCursor
    // BSON Parser, ensure we have a single instance
    , bsonInstance: bsonInstance
    // Pick the right bson parser
    , bson: options.bson ? options.bson : bsonInstance
    // Special replicaset options
    , secondaryOnlyConnectionAllowed: typeof options.secondaryOnlyConnectionAllowed == 'boolean'
    ? options.secondaryOnlyConnectionAllowed : false
    , haInterval: options.haInterval || 10000
    // Are we running in debug mode
    , debug: typeof options.debug == 'boolean' ? options.debug : false
    // The replicaset name
    , setName: options.setName
    // Swallow or emit errors
    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
    // Grouping tag used for debugging purposes
    , tag: options.tag
    // Do we have a not connected handler
    , disconnectHandler: options.disconnectHandler
    // Currently connecting servers
    , connectingServers: {}
    // Contains any alternate strategies for picking
    , readPreferenceStrategies: {}
    // Auth providers
    , authProviders: {}
    // All the servers
    , disconnectedServers: []
    // Initial connection servers
    , initialConnectionServers: []
    // High availability process running
    , highAvailabilityProcessRunning: false
    // Full setup
    , fullsetup: false
    // All servers accounted for (used for testing)
    , all: false
    // Seedlist
    , seedlist: seedlist
    // Authentication in progress
    , authInProgress: false
    // Servers added while auth in progress
    , authInProgressServers: []
    // Minimum heartbeat frequency used if we detect a server close
    , minHeartbeatFrequencyMS: 500
  }

  // Add bson parser to options
  options.bson = this.s.bson;
  // Set up the connection timeout for the options
  options.connectionTimeout = options.connectionTimeout || 10000;

  // Replicaset state
  var replState = new State(this, {
      id: this.s.id, setName: this.s.setName
    , connectingServers: this.s.connectingServers
    , secondaryOnlyConnectionAllowed: this.s.secondaryOnlyConnectionAllowed
  });

  // Add Replicaset state to our internal state
  this.s.replState = replState;

  // BSON property (find a server and pass it along)
  Object.defineProperty(this, 'bson', {
    enumerable: true, get: function() {
      var servers = self.s.replState.getAll();
      return servers.length &gt; 0 ? servers[0].bson : null;
    }
  });

  Object.defineProperty(this, 'id', {
    enumerable:true, get: function() { return self.s.id; }
  });

  Object.defineProperty(this, 'haInterval', {
    enumerable:true, get: function() { return self.s.haInterval; }
  });

  Object.defineProperty(this, 'state', {
    enumerable:true, get: function() { return self.s.replState; }
  });

  //
  // Debug options
  if(self.s.debug) {
    // Add access to the read Preference Strategies
    Object.defineProperty(this, 'readPreferenceStrategies', {
      enumerable: true, get: function() { return self.s.readPreferenceStrategies; }
    });
  }

  Object.defineProperty(this, 'type', {
    en ...</pre></li>
<li>example usage<pre class="docApiCodePre">...
  // The actual test we wish to run
  test: function(configuration, test) {
    var Db = configuration.require.Db
, Server = configuration.require.Server
, ReplSet = configuration.require.ReplSet;

    setUp(configuration, function(err) {
var replSet = new <span class="docApiCodeKeywordSpan">ReplSet</span>( [
    new Server( 'localhost', replSetManager.startPort),
    new Server( 'localhost', replSetManager.startPort + 1)
  ],
  {rs_name: replSetManager.replicasetName, poolSize:1}
);

// Connect
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.ScramSHA1" id="element.mongodb.core.ScramSHA1">
function <span class="docApiSignatureSpan">mongodb.core.</span>ScramSHA1
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">ScramSHA1 = function () {
  this.authStore = [];
}</pre></li>
<li>example usage<pre class="docApiCodePre">...

 // Add auth providers
 this.addAuthProvider('mongocr', new MongoCR());
 this.addAuthProvider('x509', new X509());
 this.addAuthProvider('plain', new Plain());
 this.addAuthProvider('gssapi', new GSSAPI());
 this.addAuthProvider('sspi', new SSPI());
 this.addAuthProvider('scram-sha-1', new <span class="docApiCodeKeywordSpan">ScramSHA1</span>());
}

inherits(Server, EventEmitter);

/**
* Execute a command
* @method
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.Server" id="element.mongodb.core.Server">
function <span class="docApiSignatureSpan">mongodb.core.</span>Server
<span class="docApiSignatureSpan">(options)</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">Server = function (options) {
  var self = this;

  // Add event listener
  EventEmitter.call(this);

  // BSON Parser, ensure we have a single instance
  if(bsonInstance == null) {
    bsonInstance = new BSON(bsonTypes);
  }

  // Reconnect retries
  var reconnectTries = options.reconnectTries || 30;

  // Keeps all the internal state of the server
  this.s = {
    // Options
      options: options
    // Contains all the callbacks
    , callbacks: new Callbacks()
    // Logger
    , logger: Logger('Server', options)
    // Server state
    , state: DISCONNECTED
    // Reconnect option
    , reconnect: typeof options.reconnect == 'boolean' ? options.reconnect :  true
    , reconnectTries: reconnectTries
    , reconnectInterval: options.reconnectInterval || 1000
    // Swallow or emit errors
    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
    // Current state
    , currentReconnectRetry: reconnectTries
    // Contains the ismaster
    , ismaster: null
    // Contains any alternate strategies for picking
    , readPreferenceStrategies: options.readPreferenceStrategies
    // Auth providers
    , authProviders: options.authProviders || {}
    // Server instance id
    , id: serverId++
    // Grouping tag used for debugging purposes
    , tag: options.tag
    // Do we have a not connected handler
    , disconnectHandler: options.disconnectHandler
    // wireProtocolHandler methods
    , wireProtocolHandler: options.wireProtocolHandler || new PreTwoSixWireProtocolSupport()
    // Factory overrides
    , Cursor: options.cursorFactory || BasicCursor
    // BSON Parser, ensure we have a single instance
    , bsonInstance: bsonInstance
    // Pick the right bson parser
    , bson: options.bson ? options.bson : bsonInstance
    // Internal connection pool
    , pool: null
    // Server details
    , serverDetails: {
        host: options.host
      , port: options.port
      , name: options.port ? f("%s:%s", options.host, options.port) : options.host
    }
  }

  // Reference state
  var s = this.s;

  // Add bson parser to options
  options.bson = s.bson;

  // Set error properties
  getProperty(this, 'name', 'name', s.serverDetails, {});
  getProperty(this, 'bson', 'bson', s.options, {});
  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
  getSingleProperty(this, 'id', s.id);

  // Add auth providers
  this.addAuthProvider('mongocr', new MongoCR());
  this.addAuthProvider('x509', new X509());
  this.addAuthProvider('plain', new Plain());
  this.addAuthProvider('gssapi', new GSSAPI());
  this.addAuthProvider('sspi', new SSPI());
  this.addAuthProvider('scram-sha-1', new ScramSHA1());
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
}
  },
  
  // The actual test we wish to run
  test: function(configure, test) {
var db = configure.newDbInstance({w:1}, {poolSize:1});

// DOC_LINE var db = new Db('test', new <span class="docApiCodeKeywordSpan">Server</span>('localhost', 27017));
// DOC_START
db.open(function(err, db) {
  // Some docs for insertion
  var docs = [{
      title : "this is my title", author : "bob", posted : new Date() ,
      pageViews : 5, tags : [ "fun" , "good" , "fun" ], other : { foo : 5 },
      comments : [
...</pre></li>
</ul>

<h2><a href="#element.mongodb.core.X509" id="element.mongodb.core.X509">
function <span class="docApiSignatureSpan">mongodb.core.</span>X509
<span class="docApiSignatureSpan">()</span>
</a></h2>
<ul>
<li>description and source code<pre class="docApiCodePre">X509 = function () {
  this.authStore = [];
}</pre></li>
<li>example usage<pre class="docApiCodePre">...
  getProperty(this, 'name', 'name', s.serverDetails, {});
  getProperty(this, 'bson', 'bson', s.options, {});
  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
  getSingleProperty(this, 'id', s.id);

  // Add auth providers
  this.addAuthProvider('mongocr', new MongoCR());
  this.addAuthProvider('x509', new <span class="docApiCodeKeywordSpan">X509</span>());
  this.addAuthProvider('plain', new Plain());
  this.addAuthProvider('gssapi', new GSSAPI());
  this.addAuthProvider('sspi', new SSPI());
  this.addAuthProvider('scram-sha-1', new ScramSHA1());
}

inherits(Server, EventEmitter);
...</pre></li>
</ul>

</div>

</div>
